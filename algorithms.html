<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-11-30 Tue 14:32 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Competitive Programming for Programming Interviews</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  body {
  max-width: 40rem;
  padding: 1rem;
  margin: auto;
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {background-color: #fafad2} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Competitive Programming for Programming Interviews</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#What%20is%20this">What is this</a>
<ul>
<li><a href="#Why%20not%20leetcode">Why not leetcode</a></li>
</ul>
</li>
<li><a href="#Materials">Materials</a>
<ul>
<li><a href="#Backups">Backups</a></li>
<li><a href="#Languages">Languages</a></li>
<li><a href="#Using%20a%20phone%2Ftablet">Using a phone/tablet</a></li>
<li><a href="#Real%20contests">Real contests</a></li>
<li><a href="#An%20example%20competitive%20programming%20class">An example competitive programming class</a></li>
<li><a href="#An%20example%20competition%20practice">An example competition practice</a></li>
</ul>
</li>
<li><a href="#Begin">Begin</a>
<ul>
<li><a href="#Preface%20-%20How%20many%20problems">Preface - How many problems</a></li>
<li><a href="#Chapter%201">Chapter 1</a></li>
<li><a href="#C%2B%2B%20crash%20course">C++ crash course</a></li>
<li><a href="#Problems">Problems</a></li>
</ul>
</li>
<li><a href="#Asymptotics">Asymptotics</a>
<ul>
<li><a href="#Computational%20model">Computational model</a></li>
<li><a href="#Logarithms">Logarithms</a></li>
<li><a href="#CS%20Theory%20Toolkit%20lecture%202">CS Theory Toolkit lecture 2</a></li>
<li><a href="#Asymptopia">Asymptopia</a></li>
</ul>
</li>
<li><a href="#6.006%20Lecture%202">6.006 Lecture 2</a>
<ul>
<li><a href="#Problem%20session%201">Problem session 1</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-What%20is%20this" class="outline-2">
<h2 id="What%20is%20this">What is this</h2>
<div class="outline-text-2" id="text-What%20is%20this">
<p>
How to game the current technical interview system for fun and profit. We need to be able to do <a href="https://news.ycombinator.com/item?id=25302104">this</a>: "it's not enough to be able to solve the problems, you need to be able to solve them on the spot, without much thinking, in an interview context". This is exactly what competitive programming teaches: a toolkit of problem solving strategies followed by a lot of practice so you become faster. Even if you don't want to be a wagie you can use this as free education, get in and stay long enough so you can learn to become a freelance contractor.
</p>
</div>

<div id="outline-container-Why%20not%20leetcode" class="outline-3">
<h3 id="Why%20not%20leetcode">Why not leetcode</h3>
<div class="outline-text-3" id="text-Why%20not%20leetcode">
<p>
Leetcode costs money to get the good problems, while competitive programming is free. The hardest problems on free tier leetcode are rated about 3.6 of 10 on Kattis, the online judge we will use. The problems we will work up to are similar in goal to math olympiad problems, the idea is that you really learn the art of problem solving to apply it to everything in life like open problems in theoretical CS research not just for passing some interview test. Since Kattis is non-commercial universities have their assignments there such as <a href="https://algo.is/competitive-programming-course/">Reykjavik</a> or <a href="https://nus.kattis.com/">NUS</a> or <a href="https://kth.kattis.com/courses/DD2458">KTH</a> Stockholm 'programming under pressure' course.  
</p>
</div>
</div>
</div>

<div id="outline-container-Materials" class="outline-2">
<h2 id="Materials">Materials</h2>
<div class="outline-text-2" id="text-Materials">
<p>
Every book listed here is free from <a href="https://en.wikipedia.org/wiki/Library_Genesis">Library Genesis</a> or search WorldCat library if you can't buy them:
</p>

<ul class="org-ul">
<li>The <a href="https://cpbook.net/details?cp=4">book</a> <i>Competitive Programming 4</i> (the first volume, 4 chapters)</li>
</ul>

<p>
The first volume was written both for passing technical interviews and for anybody interested in beginning competitive programming as the author is the coach of Singapore's ICPC/IOI team. Practice is done with the <a href="https://open.kattis.com/">Kattis Problem Archive</a> and some other online judges, so producing working code for hundreds of problems and submitting them for tests of correctness and problem runtime constraints. Kattis also hosts the ICPC <a href="https://icpc.kattis.com/problems">archive</a> problems which when we're done if you're interested we'll try and <a href="http://www.cs.cmu.edu/~15850/notes/cmu850-f20.pdf">do those too</a>. Kattis even hosts the NSA <a href="https://nsachallenge20.kattis.com/problems">challenges</a>. All the algorithms have visualizations on the author's site <a href="https://visualgo.net/en">VisuAlgo</a>.
</p>

<ul class="org-ul">
<li>MIT's <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2020/">6.006</a> sp2020 course on OCW w/open lectures</li>
</ul>

<p>
Contains full problem walkthroughs. I preferred this course to others because they actually use a board, instead of zoom slides so you can see problems being fully worked out. We have access to everything and it's permanent so won't disappear behind logins. As a bonus this course tells you how Python standard libraries are implemented, should you wish to use it for interviews. 
</p>

<ul class="org-ul">
<li>Other materials to fill in gaps</li>
</ul>

<p>
Some from: UCSD's CSE101 <a href="https://cseweb.ucsd.edu/~dakane/CSE101/">course</a>, Ryan O'donnell's <a href="https://www.youtube.com/playlist?list=PLm3J0oaFux3ZYpFLwwrlv_EHH9wtH6pnX">CS Theory Toolkit</a>, CMU's 15-451 <i>Algorithms</i> undergrad <a href="https://www.cs.cmu.edu/~15451-f20/schedule.html">course</a> to learn FFT/Computational Geometry, and 15-295 <i>Competitive Programming</i>. The <a href="https://cs.nyu.edu/~spencer/">book</a> <i>Asymptopia</i> by Spencer and <a href="https://cseweb.ucsd.edu/~dasgupta/book/index.html">DPV</a> which we'll do very few parts of each. CMU's <i>Parallel &amp; Sequential Algorithms</i> <a href="https://www.diderot.one/courses/89">book</a>. We will also study software architecture <a href="https://www.worldcat.org/title/system-design-interview-an-insiders-guide-second-edition/oclc/1253363956&amp;referer=brief_results">examples</a>. 
</p>
</div>

<div id="outline-container-Backups" class="outline-3">
<h3 id="Backups">Backups</h3>
<div class="outline-text-3" id="text-Backups">
<p>
These are only needed if the public online resources disappear
</p>

<ul class="org-ul">
<li>CSE101 <a href="https://btcache.me/torrent/D3B621E29F1C4647E37E5111A1B28FDB790BB056">torrent file</a> contains recorded lectures, all assignments/solutions and past exams/solutions, didn't add the exam review lectures.</li>

<li>15-451 <a href="https://btcache.me/torrent/A898A215DDF9FA5E2BAF3F160EA2E9CC41128A04">torrent file</a> some recorded lectures &amp; recitations</li>
</ul>
</div>
</div>

<div id="outline-container-Languages" class="outline-3">
<h3 id="Languages">Languages</h3>
<div class="outline-text-3" id="text-Languages">
<p>
The book has a public code <a href="https://github.com/stevenhalim/cpbook-code">repository</a> of all the algorithms contained in it, and explains the complexity of the standard library data structures for OCaml, Python 3, Java 11 and C++17 but you can use any of <a href="https://open.kattis.com/help">these</a> languages. You don't have to use their specific compiler version for your local system, just be aware of any differences in versions when you make a submission so not using some feature that doesn't exist yet in the Kattis version. Whatever language you choose guaranteed there is a tutorial for using it for competitive programming like this <a href="https://byorgey.wordpress.com/2019/04/24/competitive-programming-in-haskell-basic-setup/">Haskell</a> example. Here I will use <a href="http://libgen.is/book/index.php?md5=595216785D9250951566D4D33E8A14BF">functional C++</a> essentially programming similar to the style in the <a href="./software.html">CS19</a> workshop. 
</p>

<p>
Here are the rules of the ICPC world finals and the <a href="https://docs.icpc.global/worldfinals-programming-environment/">languages</a> they allow, though judges only guarantee solutions with passing tests in C++ and Java, but it doesn't mean you can't have AC verdict with other languages.
</p>
</div>
</div>

<div id="outline-container-Using%20a%20phone%2Ftablet" class="outline-3">
<h3 id="Using%20a%20phone%2Ftablet">Using a phone/tablet</h3>
<div class="outline-text-3" id="text-Using%20a%20phone%2Ftablet">
<p>
Looking around the Android store, the only decent offline app seems to be a <a href="https://youtu.be/FeWBu9Gf-Rs">Pascal</a> compiler made by a highschool kid in Vietnam. Both Kattis and onlinejudge.org accept Pascal submissions (I think the IOI still accepts it) and Pascal syntax is almost simple pseudocode. If you want an online compiler there are many options like <a href="https://replit.com/">Repl.it</a>.
</p>
</div>
</div>

<div id="outline-container-Real%20contests" class="outline-3">
<h3 id="Real%20contests">Real contests</h3>
<div class="outline-text-3" id="text-Real%20contests">
<p>
We can compete on CodeForces, <a href="https://icfpcontest2021.github.io/index.html">ICFP</a>, Topcoder, Google Kickstart, Facebook Hacker Cup, <a href="https://code.golf/">Code Golf</a>, <a href="https://microcorruption.com/login">microcorruption</a> or <a href="https://cryptopals.com/">cryptopals</a> type challenges, most of which we have <i>no hope of winning</i> of course but it's practice to pick up more speed and experience. 
</p>
</div>
</div>

<div id="outline-container-An%20example%20competitive%20programming%20class" class="outline-3">
<h3 id="An%20example%20competitive%20programming%20class">An example competitive programming class</h3>
<div class="outline-text-3" id="text-An%20example%20competitive%20programming%20class">
<p>
A great writeup <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">here</a> of an exchange student from Canada who took CS 3233 in Singapore and how the author of the cp4 book organizes those classes. It's a 12 day course expanded to 4 months as most of the work is the class competing against each other. He recommends learning to modify existing algorithms instead of using fancy data structures.
</p>
</div>
</div>

<div id="outline-container-An%20example%20competition%20practice" class="outline-3">
<h3 id="An%20example%20competition%20practice">An example competition practice</h3>
<div class="outline-text-3" id="text-An%20example%20competition%20practice">
<p>
Here is Gennady Korotkevich aka tourist <a href="https://youtu.be/97tieEKfvBs">practicing</a> on codeforces and explaining what he's doing, though he didn't start with C++ he used to win the IOI with Pascal. A good article about him is <a href="http://is.ifmo.ru/articles_en/2017/4-17_eng.pdf">here</a> which explains the spartan background, he chooses to live in a student dorm. At school he gives lectures on discrete math/combinatorics and complexity theory which makes sense, if you are a master problem solver you are likely interested in trying to figure out unsolved problems in theoretical cs. 
</p>

<p>
The first thing to notice is he's using a generic text editor and unusual shell that looks like minimalist GNU for Windows(<a href="https://mingw.osdn.io/">MinGW</a>) and a text mode <a href="https://www.farmanager.com/screenshots.php?l=en">file manager</a> and manually submitting through the codeforces website UI. He prepares individual directories named after the problem, then always makes a sol.cpp file in that directory so he doesn't have to change a macro he's written to compile the solution from the shell. 
</p>

<p>
His C++ template:
</p>
<pre class="example" id="org6ebc6fb">
// include every C++ std library and bits library
// doesn't work on all platforms
#include &lt;bits/stdc++.h&gt;

// use std namespace to avoid having to write std::cin or std::cout
using namespace std;

int main() {
// turn off default cout flush
 ios::synch_with_stdio(false);
 cin.tie(0)

int tt;
cin &gt;&gt; tt;
// store first input tt as int
while (tt--) {
// while (true) do following..
// way to decrement through the input stream to zero
</pre>

<p>
std::cin is synchronized to std::cout and performs default buffer flushing operations, so to save runtime he disables this sync. This is all written in online C++ references you can read yourself if you choose to use C++. His compiler flags he explains in one of these Twitch streams, or you can figure out yourself too as you go, most of them are to make compiler messages extra verbose for debugging. 
</p>

<p>
You don't have to watch the entire 2hr vid, the last problem seems like the most informative. He begins most problems by writing himself examples as comments, something we already learned in <a href="./software.html">CS19</a>. He copies the problem input test cases into a text file 'in1' then pipes it into his compiled program "sol.exe &lt; in1" as stdin (standard input). He writes multiple submissions to compare their runtime/memory usage. He looks for some kind of mathematical structure in the formulas given in the problem writeup. After submission he looks up the solutions by the problem writers and compares them to his own.    
</p>

<p>
@1:43:48 or so he reads the writeup for a problem describing local maximum and minimum, which is the chapter on optimization in the calculus book we do <a href="./calculus.html">here</a> if you're interested. In the last problem he get's time limit exceeded verdict and trolls his live stream that replacing all the variable names with a single letter will make it run faster. His solution had nested initialization of numerous vectors inside loops, so everytime they loop you init another vector(s), once he removed those out of the loop he achieved accepted verdict. The judging server ran his program faster than his own laptop, something to remember if debugging and believing your solution still isn't optimized enough. 
</p>
</div>
</div>
</div>

<div id="outline-container-Begin" class="outline-2">
<h2 id="Begin">Begin</h2>
<div class="outline-text-2" id="text-Begin">
<p>
I assume you either downloaded the book <i>Competitive Programming 3</i> from library genesis or bought the 4th edition for $20, it's handbook sized and worth the money as it has a ton of solved exercises just in the book itself, not including the huge amount of UVa/Kattis problems it recommends doing. 
</p>

<p>
This book is designed to be read several times, you work through it once then go back and solve the exercises in each chapter, as they won't make sense the first time around. The author(s) are very blunt in saying if you want to compete, you should know everything in this book and be able to solve many of these problems in under 30 minutes, if very competitive under 10 minutes. You get to that level through practice and always trying to work just above your skill level so you are always advancing. 
</p>
</div>

<div id="outline-container-Preface%20-%20How%20many%20problems" class="outline-3">
<h3 id="Preface%20-%20How%20many%20problems">Preface - How many problems</h3>
<div class="outline-text-3" id="text-Preface%20-%20How%20many%20problems">
<p>
Each chapter topic will have 7 starred 'must try' problems, and all of them are on the site <a href="https://cpbook.net/methodstosolve">methods to solve</a> and that site is more up to date than the book, it's the site we will use so if you don't buy the 4th edition, you're fine. It contains a mix of onlinejudge.com (formerly called UVa online judge) and Kattis problem sets, the bold problem titles are the recommended problems. Hints how to solve them are on the right-hand side if you haven't figured it out but the book explains that's how the authors solved them, but there could be other ways. The CP4 book 1 satisfies the majority of the 2020 IOI syllabus (and also 2021 syllabus since 2020 was virtual/cancelled, even ICPC 2021 changed to March 2022) and it was also designed for passing tech interviews.  
</p>

<p>
If we only do the starred problems listed on <a href="https://cpbook.net/methodstosolve">methods to solve</a> how many are we looking at? Chapter 4 has 167, 3 has 195, 2 has 165 and the first chapter has 182 or <b>709 total problems</b> if you're using both UVa and Kattis. If you read the above example class writeup of that exchange student, he solved <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">50 problems a day</a> when first started and gained 500 points on Kattis in 2 months, which is the entrance requirement for the course, then he gained 1000 more points on Kattis during his 4 month course in Singapore (noting another student gained 3500 points in 4 months) so this isn't impossible to do.
</p>
</div>
</div>

<div id="outline-container-Chapter%201" class="outline-3">
<h3 id="Chapter%201">Chapter 1</h3>
<div class="outline-text-3" id="text-Chapter%201">
<p>
Most of this hasn't changed since CP3, this is a casual read. 1.3.2 problem solving skills are mentioned, many of which were taught in <a href="./software.html">CS19</a>. 1.3.3 modern (2020) CPUs can process 10<sup>8</sup> or 100M operations in a second for our solutions, on average, so they recommend to pay attention to bounds if your algorithm is n<sup>4</sup> in complexity but the input is only 50 inputs max, you could still pass the online judge. The book notes that we should already have the skills to judge the runtime complexity of our own algorithms, which we will learn as we go.
</p>

<p>
1.3.4 talks about programming languages, how factorials like 40! are trivial in Python but difficult in C/C++, and requires a special library BigInteger in Java. The point being you should know multiple languages enough to be able to solve any problem with them (or know the Stirling numbers asymptotic trick to get a sum of factorials). The rest of this chapter will show you how to get your first AC verdict on Kattis, and has multiple examples of how to get and manipulate input which of course are also on the book github repository. 
</p>
</div>
</div>

<div id="outline-container-C%2B%2B%20crash%20course" class="outline-3">
<h3 id="C%2B%2B%20crash%20course">C++ crash course</h3>
<div class="outline-text-3" id="text-C%2B%2B%20crash%20course">
<p>
The cp4 book and <a href="https://kth.instructure.com/courses/20699/files/3296468/download?verifier=xTIE4fipNDoRb4BXNI7TiLOAtpuekegxbZZ5XO4M&amp;wrap=1">Algorithmic Problem Solving</a> 2020 draft by Johan Sannemo explain all you need to know about C++ to begin with the chapter 1 <i>Methods to Solve</i> problems. The Sannemo written draft covers some basics of the STL like I/O or how to nest vectors and the cp4 book will tell you how vectors are implemented. If you want to do the problems in the Sannemo book type their name into Kattis search. Both books will explain the time complexity of the standard library data structures, and the Sannemo book will show you the C++ computational model for manually adding up costs, creating a T(n) expression you can then simplify as we will soon learn.
</p>

<p>
A good book is <i>The Design and Evolution of C++</i> by Stroustrup you can find on library genesis, explaining the reasoning for why C++ is the way it is, such as why are structs and classes the same thing. The book is very outdated but I still find it helpful.
</p>

<p>
Another book I bought was <a href="http://libgen.is/book/index.php?md5=595216785D9250951566D4D33E8A14BF">Functional Programming in C++</a> as we are using C++17 on Kattis so lambdas and transforms are built-in. To begin I do not include every C++ library like in most competitive programming templates, instead I've been manually typing std::vector&lt;thing&gt; until I'm so familiar with the standard library I can graduate to a template opening up all their namespace by default. You can get very fast at <a href="https://play.typeracer.com/">typing</a> the full library names. 
</p>

<p>
Keep in mind C++ <a href="https://youtu.be/YnWhqhNdYyk">is not C</a>. 
</p>
</div>
</div>

<div id="outline-container-Problems" class="outline-3">
<h3 id="Problems">Problems</h3>
<div class="outline-text-3" id="text-Problems">
<p>
Here are <a href="https://cpbook.net/methodstosolve?oj=kattis&amp;topic=ch1&amp;quality=starred">97 starred problems</a> from the cp4 book chapter 1, if you are only using Kattis online judge. Basic I/O like input parsing and output formatting for language of choice is <a href="https://open.kattis.com/help">here</a> or see the book github repository for chapter 1. If you want even more practice, do both the regular and starred Kattis problems of which there are <a href="https://cpbook.net/methodstosolve?oj=kattis&amp;topic=ch1&amp;quality=all">211</a> on the methods to solve website. If you want to use both Kattis and onlinejudge.org there is <a href="https://cpbook.net/methodstosolve?oj=both&amp;topic=ch1&amp;quality=all">479</a> chapter 1 problems in total for both sites.
</p>

<p>
If you click on the problem name on the furthest left column, a hint is revealed or install the Kattis Hint Giver chrome addon as suggested. 
</p>

<p>
Read 1.4 <i>Ad-Hoc Problems</i> as you do them from the book if using the 3rd version. In cp4, they moved chapter 6.2 <i>Basic String Processing Skills</i> from 3rd version to the first chapter, read that too. The author claims this is all we will need for most of the problems they selected on <i>Methods to solve</i> though some of these ad-hoc problems have difficulty reaching into 5+ meaning they may require some kind of future skill like backtracking to solve, try them with your current skill anyway.
</p>

<p>
To get the hang of C++ I/O rewatch Gennady's walkthrough how he retrieved input while you have cppreference.com open to view the standard library functions. You will learn by doing, here's an example of some of the first few <i>Methods to Solve</i> problems:
</p>

<pre class="example" id="org3a8acbd">
// problem Faktor
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; 1 + round(a * (b - 1)) &lt;&lt; endl;
  return 0;
}

// problem carrots
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
  int total, answer;
  cin &gt;&gt; total &gt;&gt; answer;
  // first input determines how many throwaway 3rd inputs:
  vector&lt;string&gt; a(total);
  for (int i = 0; i &lt; total; i++) {
    cin &gt;&gt; a[i];
  }
  cout &lt;&lt; answer;
  return 0;
}
</pre>

<p>
I haven't untied cout/cin yet since we are a long way from needing that optimization, also don't care about error handling, we are doing this to gain intuitive expertise in algorithms all the real life error handling and testing for software development we will do later. Right now just hack away until this is second nature.  
</p>
</div>
</div>
</div>

<div id="outline-container-Asymptotics" class="outline-2">
<h2 id="Asymptotics">Asymptotics</h2>
<div class="outline-text-2" id="text-Asymptotics">
<p>
While you drill some chapter 1 Kattis problems for practice, we are leaving the world of precision math for the rest of this workshop and entering the wild and crazy art of asymptotics where we get to estimate everything with slippery definitions. For the most part we will disregard constants except in competitive programming since the bounds are so restricted. 
</p>
</div>

<div id="outline-container-Computational%20model" class="outline-3">
<h3 id="Computational%20model">Computational model</h3>
<div class="outline-text-3" id="text-Computational%20model">
<p>
First, if you did not do CS19, then watch <a href="https://youtu.be/-dQAGsSrKBA">this</a> which is lecture 4 of CS19 where Prof K explains a computational model. You can, even if you only know Python or another language, probably figure out the simple Pyret cases syntax which you can interpret as an if-statement: if this link is empty then return 0, if not empty +1 and then call the function again with one less element in the list until we add up the length. There's also a writeup <a href="https://papl.cs.brown.edu/2020/predicting-growth.html#%28part._math-anon-functions%29">here</a> and these <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html">notes</a> have an excellent introduction to the ambiguities of Big-O notation, what a computation model is, what 'running time' means.
</p>

<p>
The MIT 6.006 course we do will explain all this as well.  
</p>
</div>
</div>

<div id="outline-container-Logarithms" class="outline-3">
<h3 id="Logarithms">Logarithms</h3>
<div class="outline-text-3" id="text-Logarithms">
<p>
Chapter 0.3 of <i>Algorithms</i> by <a href="https://cseweb.ucsd.edu/~dasgupta/book/index.html">DPV</a> read through it once, then skip to page 12 of 1.1 <i>Basic Arithmetic</i> and read the bases and logs aside if you forgot them. It's still not enough though, procure <i>The Art of Computer Programming, Vol. 1</i> either by <a href="http://library.lol/main/3612CEBCEE66E75A23440B97A1B560DB">library genesis</a> or buy a copy it'll be the best book you'll ever own. Skip to 1.2.2 <i>Numbers, Powers, and Logarithms</i>. We are interested in page 22 and 23, the laws of exponents for integer exponents, and rational exponents, and all the logarithm identities. A log is an exponent, so exactly how you combine exponents is how you manipulate logs for example log(xy) when you multiply two bases b<sup>y</sup> * b<sup>x</sup> you add exponents, so log(xy) is log(x) + log(y).
</p>

<p>
Find everything you can YouTube about logarithms such as <a href="https://youtu.be/AAW7WRFBKdw">this</a>. @3:29 in that video be aware you can take any number like 3, and make it into a log ie: log<sub>10</sub> 1000 = 3 this is why it will often seem in algorithm/complexity books they take logs out of thin air and substitute them in to make something easier to simplify, this is what they are doing.  
</p>

<p>
Prof K in CS19 also has a nice intuition for logarithmic growth, which is how many zeros a number has. If an algorithm is logarithmic in the number of steps and inputs increase by 1 million, then work increased by a factor of only 6. An algorithm doing logarithmic steps means at every iteration of your algorithm you throw away half the input.  
</p>

<p>
In the <a href="./calculus.html">calculus</a> workshop there's a great chapter and lectures on ln(x) or the 'natural logarithm' if you've never seen it before, breaking it down into parts like what are the parameters to a log() function and what do they do. 
</p>
</div>
</div>

<div id="outline-container-CS%20Theory%20Toolkit%20lecture%202" class="outline-3">
<h3 id="CS%20Theory%20Toolkit%20lecture%202">CS Theory Toolkit lecture 2</h3>
<div class="outline-text-3" id="text-CS%20Theory%20Toolkit%20lecture%202">
<p>
Let's starts with asymptotics, this is the most confusing part of any algorithms course mainly because it's always presented poorly or hand waved that you will learn it in some future advanced course. If you forgot this notation, f(x) is your algorithm modeled as a function of running time, ie: if you discover your algorithm is T(n) = 10n + 20, then f(x) is 10x + 20 and g(x) is a function you wish to use as a bound for your f(x) modeled algorithm. All the inputs to each 'approach infinity' in this model. 
</p>

<p>
Watch <a href="https://youtu.be/_gKb855_3bk">Big O and friends</a> part of a lecture from CMU's CS Theory Toolkit. You can type all these definitions into desmos to see their visualization like I did <a href="https://www.desmos.com/calculator/xzqea0wfwc">here</a>, then keep zooming out to see how they change when inputs become gigantic. The constant and logarithm (log n) become indistinguishable, n log(n) grows very slowly towards 2<sup>x</sup> because it's linear times some logarithmic factor. 'Factor' here means you are multiplying two things, so they will like in highschool break into factors and one will be logarithmic because you multiplied n by log(n). 
</p>

<p>
@1:58 x<sub>0</sub> or 'x naught' means a particular input to f(x) so x<sub>0</sub> for example can be f(5), so all inputs to f(x) equal or greater than 5 this definition holds. @5:40 his anonymous function, that's the Prof K interpretation from CS19, O(n<sup>2</sup>) by itself without the entire f(x) = definition is O([n -&gt; n<sup>2</sup>]). @12:00 10n/n<sup>2</sup> and you jack up inputs to approach infinity you will get a limit of 0, and thus 10n is in the little-o family of functions that are stricly less than the family of functions in n<sup>2</sup> however 10n is still in the family of functions that are Big-O of n<sup>2</sup> (and anything else bigger than linear). @13:29 the anonymous function again, O(1) means O([n -&gt; c]) for all inputs what we get is bounded by a constant. 14:50 log<sup>3</sup> n means (log(n))<sup>3</sup> and since all logarithms are really exponents it's log(n<sup>3</sup>) since (b<sup>1</sup>)<sup>2</sup> is b<sup>2</sup> and this is called a <a href="https://en.wikipedia.org/wiki/Polylogarithmic_function">polylogarithmic</a> function 'a polynomial in the logarithm of n' and denotes it is growing more slowly than any positive polynomial exponent, because it's a log. 
</p>

<p>
This is worth expanding on, a polynomial 'in x' means what you learned <a href="https://math.stackexchange.com/a/2185613">highschool</a> The first 10 minutes or so of <a href="https://youtu.be/JpPNzdlXVYw">this</a> lecture explains why we use them. Here we are talking about a polynomial 'in n' so replace all the x's with the function n or polylogarithmic replace all the x's with log(n). To me at my pleb level of mathematics it means there is a vector space in that function since multiplying/adding a polynomial gives you another one, or it's a object of type Integer <a href="https://youtu.be/H8xBlLWdzBE">ring</a>. 
</p>

<p>
@14:25 let's figure out O-tilde and poly() which you will see in every algorithm paper:
</p>

<ul class="org-ul">
<li>poly(g(x)) or f(x) = g(x)<sup>O(1)</sup>
<ul class="org-ul">
<li>any growth in the form of big-O with a constant exponent</li>
<li>example: O(n)<sup>2</sup> is poly(g(x))</li>
</ul></li>
<li>O-tilde(g(x)) or f(x) = g(x) * log(g(x))<sup>O(1)</sup>
<ul class="org-ul">
<li>fx = g(x) * poly(log(gx))</li>
<li>any growth in the form of g(x) * a logarithmic factor of g(x)</li>
</ul></li>
</ul>

<p>
Let's figure out his \(\widetilde{O}\)(g(x)) definition. You suppress the polylogarithmic factors because they're growing much more slowly than whatever the dominant or significant growth is. He took \(n^5 \cdot 3^{n}\) and used O-tilde to model it's bound:
</p>

<ul class="org-ul">
<li>n<sup>5</sup> * poly(log(3<sup>n</sup>) or g(x) * poly(log(g(x)))
<ul class="org-ul">
<li>which is n<sup>5</sup> * poly(n * log 3)</li>
<li>which is n<sup>5</sup> * poly(n<sup>O(1)</sup> * discarded constant)</li>
<li>which is 3<sup>n</sup> * poly(n) because all those factors of n<sup>5</sup> they don't matter and are miniscule in comparison to the growth of 3<sup>n</sup> and this asymptotic notation allows us to suppress poly(log c, n) factors and n<sup>5</sup> is n<sup>O(1)</sup></li>
</ul></li>
</ul>

<p>
He remarks O-tilde indicates there's some logarithmic growth factors in your bound that you don't care about/couldn't pin down. His check that this isn't 2<sup>n</sup> he uses the first chapter of DPV where they show testing a f(x)/g(x) ratio so 3<sup>n</sup> over 2<sup>n</sup> = 1.5<sup>n</sup> and making sure it's not smaller than poly(n), which it's not since any n<sup>O(1)</sup> will never outgrow 1.5<sup>n</sup> exponential function. 
</p>

<p>
Everything past 22:00 or so is in the book <i>Asymptopia</i> by Spencer talking about standard form of functions you want to use for g(x) which is the function you use to compare/bound your algorithm f(x) to, for example sqrt(n) is standard form but sqrt(n + 1) isn't. He shows how to fix this in part 3. 
</p>

<p>
Moving on to <a href="https://youtu.be/Ao6aXSyJ6Gk">part b</a> there's an interesting illustration of harmonic numbers which will surely come up in DPV and how H<sub>n</sub> is in Big-Theta(log n) when you use asymptotics to estimate it. He uses basic integration of 1/x you can see <a href="./calculus.html">here</a> which is log(x) but the point here is manipulating results so you can get that form of something tending towards 1. He points out why you will sometimes see totally crazy looking bounds, it's from factoring things out and trying to show a final result of bound multiplied by something tending to 1, like n(1 -/+ O(1/n))    
</p>

<p>
Moving on to <a href="https://youtu.be/flge97Jp6uo">part 3</a> the magic of asymptotics: e<sup>x</sup> is roughly 1 + x for small x. The rest of lecture is showing how you take a complicated expression and simplify it with asymptotics exactly what we will see in every algorithms text or paper.  
</p>
</div>
</div>

<div id="outline-container-Asymptopia" class="outline-3">
<h3 id="Asymptopia">Asymptopia</h3>
<div class="outline-text-3" id="text-Asymptopia">
<p>
Obtain the book (either by library genesis, wordcat or buy) <i>Asymptopia</i> by Joel Spencer and skip to chapter 2 <i>Big Oh, Little Oh, and All That</i> we won't do the whole book but if you wanted to, all the Ryan O'Donnell TCS Toolkit lectures cover material from the book which you can practice with using <i>Concrete Math</i> or <i>The Art of Computer Programming vol 1</i> by Knuth. 
</p>

<p>
Watch <a href="https://youtu.be/TUwMuTf_fiA">this</a> and <a href="https://youtu.be/ADVZOhMDmQI">this</a> to see an example of LimInf/LimSup using desmos, basically you have a sequence like your algorithm producing values and as it approaches infinity somewhere in that sequence you can take a smaller subsequence and show there exists an symptotic ceiling or floor. Limit superior/inferior always exist so are used in asymptotic definitions for sequences that may not converge. He uses a periodic sine function for this where eventually 1 is the limsup and -1 is liminf. You could also read Tao's <i>Analysis</i> book chater 6, which we already did <a href="./math.html">here</a>. 
</p>

<p>
When you're done recall how to use L'Hopital's rule for limits at infinity <a href="https://www.khanacademy.org/math/ap-calculus-ab/ab-diff-contextual-applications-new/ab-4-7/v/l-hopital-s-rule-example-2">here</a> though we are not taking classical limits, it gives you an idea how you would end up with a ratio x/y that is negative. Basically you are repeatedy taking derivatives or solving with basic algebra. 
</p>

<p>
Def 2.3 of <i>Asymptopia</i> the asymptotic ceiling of f(n)/g(n) is less than infinity for f(n) = O(g(n)) meaning f(n) is bounded by g(n), and the top of the ratio isn't larger than the bottom. Ex: f(n) = n and g(n) = cn<sup>2</sup> or n/cn<sup>2</sup> which is 1/cn and converges towards zero, so not to infinity and now f(n) is in O(g(n)). 
</p>

<p>
Def 2.4 the asymptotic floor of f(n)/g(n) is greater than 0, then f(n) = Omega(g(n)) so the opposite of definition 2.3 f(n) = n<sup>2</sup> and g(n) = cn or n<sup>2</sup>/cn or n/c and with positive inputs, since we're modeling algorithms, this will never be 0 or less. 
</p>

<p>
Def 2.5 Greek letter epsilon is a variable meaning an arbitrarily small constant, like 0.1 or 0.001. If f(n) = 2n + 20 and g(n) = cn then defintion 2.5 is satisfied, you can always pick a smaller (epsilon) constant for g(n) or bigger constant c for g(n) to bound f(n) from below and above. If you pick g(n) = 0.01*n then f(n) &gt; g(n) or f(n) = big-Omega(g(n)), if you pick g(n) = 100n then f(n) &lt; g(n) and f(n) = O(g(n)) the point being f(n) is bounded below and above only by a constant, so f(n) = big-Theta(g(n)).      
</p>

<p>
Def 2.6 we already saw an example where the limit was 0, f(n) = n and g(n) = cn<sup>2</sup> or 1/cn which converges to zero, so f(n) = o(g(n)) or n is strictly less than n<sup>2</sup> and def 2.7 the opposite: f(n) = n<sup>2</sup> and g(n) = cn or n/c which grows to infinity.
</p>

<p>
Def 2.8 Similar to the O-tilde definition, where logarithmic factors exist (log n)<sup>c</sup> though here the author uses big theta to represent polylog bounds, I will use the Prof O'donnell O-tilde def of f(n) = g(n) * poly(log(g(n)))
</p>

<p>
Prop 2.9 we saw in the prof O'donnell lecture: g(n) * something approaching 1 which is what (1 + o(1)) is, remember that notation o(1) means strictly less than 1 and covered in 2.3 <i>Little Oh One</i>.
</p>

<p>
Theorem 2.10 this means O(n + n) is just O(n).
</p>

<p>
We don't have to understand the proofs, but since we're reading them anyway:
</p>

<p>
Theorem 2.13 proof, in 2.20 he first uses basic algebra to reduce (n + 1)<sup>k</sup>/n<sup>k</sup> by rewriting using laws of exponents: (n + 1/n)<sup>k</sup> then we have (n/n + 1/n)<sup>k</sup> and since this is a limit, 1/n goes to zero so we're left with (1 + 0)<sup>k</sup> or 1. Why this ratio was done is explained <a href="https://math.stackexchange.com/a/4319825">here</a>. The proof of 2.17 involves substitution to get it to resemble 2.18. The examples from 2.22 - 2.27 are important, the bigger function is whatever has the bigger c in n<sup>c</sup> or c<sup>n</sup> even negative values. 2.23 is from the Ryan O'donnell examples of polylogs. 
</p>
</div>
</div>
</div>

<div id="outline-container-6.006%20Lecture%202" class="outline-2">
<h2 id="6.006%20Lecture%202">6.006 Lecture 2</h2>
<div class="outline-text-2" id="text-6.006%20Lecture%202">
<p>
I skipped lecture 1 because it's just course logistics and brief introductions which are fully covered in this lecture. 
</p>

<p>
His example of binary arithmetic, if you don't know what it is watch <a href="https://youtu.be/f8xfVVVWXNU">this</a> lecture from 6.004 which will explain bit addition and encoding or consider doing lecture 2 and 3 (or all the lectures) of CMU's <a href="https://www.youtube.com/playlist?list=PLQ5cMeVTtiJkUilq92Cw9D6RhAJhPJ_JX">15-213</a>. I'll probably end up doing most of <a href="./theabsolutestateofsoftware.html">here</a> if interested.
</p>

<p>
Dynamic arrays in C++ are called vectors in the standard library, and are implemented exactly like this lecture where when full are copied over to a new array double it's original size. 
</p>

<p>
@45:49, there is a geometric series 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> &#x2026; he wants the last n digit of the series n = 2<sup>y</sup> which is the same as y = log<sub>2</sub> n or the other notation for base 2 which is y = lg n. Using <a href="https://brownmath.com/alge/loglaws.htm#def2">substitution</a> to get rid of the y, we get n = 2<sup>lg n</sup> or O(n) (he uses big-Theta).
</p>
</div>

<div id="outline-container-Problem%20session%201" class="outline-3">
<h3 id="Problem%20session%201">Problem session 1</h3>
<div class="outline-text-3" id="text-Problem%20session%201">
<p>
Watching <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2020/lecture-videos/problem-session-1/">this</a>. The problem session pdfs are <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2020/practice-problems/">here</a>.
</p>


<p>
TODO
</p>


<hr>
<p>
<a href="./index.html">Home</a>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
