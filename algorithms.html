<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-11-04 Thu 07:59 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Competitive Programming for Programming Interviews</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  body {
  max-width: 40rem;
  padding: 1rem;
  margin: auto;
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {background-color: #fafad2} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Competitive Programming for Programming Interviews</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#What%20is%20this">What is this</a>
<ul>
<li><a href="#Why%20wagie%20slaving">Why wagie slaving</a></li>
<li><a href="#What%20does%20a%20SWE%2FSDE%20actually%20do">What does a SWE/SDE actually do</a></li>
<li><a href="#Why%20not%20leetcode">Why not leetcode</a></li>
</ul>
</li>
<li><a href="#Materials">Materials</a>
<ul>
<li><a href="#Backups">Backups</a></li>
<li><a href="#Languages">Languages</a></li>
<li><a href="#Real%20contests">Real contests</a></li>
<li><a href="#An%20example%20competitive%20programming%20class">An example competitive programming class</a></li>
</ul>
</li>
<li><a href="#Begin">Begin</a>
<ul>
<li><a href="#Preface%20-%20How%20many%20problems">Preface - How many problems</a></li>
<li><a href="#Chapter%201">Chapter 1</a></li>
</ul>
</li>
<li><a href="#Problem%20solving%20walkthrough">Problem solving walkthrough</a></li>
<li><a href="#CSE101%20Lecture%201">CSE101 Lecture 1</a></li>
</ul>
</div>
</nav>

<div id="outline-container-What%20is%20this" class="outline-2">
<h2 id="What%20is%20this">What is this</h2>
<div class="outline-text-2" id="text-What%20is%20this">
<p>
A typical undergraduate design and analysis of algorithms class, but we practice with competitive programming resources to keep it interesting. I do this in parallel with <a href="./software.html">CS19</a> to learn graphs and dynamic programming.
</p>

<p>
This will include system design and is targeted to Palantir and Amazon, since they have recruiters everywhere and hire developers for US, Canada, India, Germany, UK, Ireland, Spain, China, Luxembourg, Poland, South Africa, Israel, Taiwan, Romania, Jordan, Australia, Netherlands, Japan, Mexico, Costa Rica, France, New Zealand, Italy, Arab Emirates, Egypt, Sweden, Finland, Chile, Austria, Greece (they pay greeks to relocate to Luxembourg) and probably a few countries I left out as I'm only going off the current vacancies on their websites. Do you live in or can get to one of those countries and want to get paid to write software with no academic background whatsoever? Read on.
</p>
</div>

<div id="outline-container-Why%20wagie%20slaving" class="outline-3">
<h3 id="Why%20wagie%20slaving">Why wagie slaving</h3>
<div class="outline-text-3" id="text-Why%20wagie%20slaving">
<p>
If you do not have experience or some kind of formal accreditation it is unlikely you will even be able to bypass the AI resume filter elsewhere whereas at Amazon or Palantir, you just need to pass the (difficult) interviews and you're in, as they have an army of recruiters always looking for new hires. The day you are hired you are free to drop Amazon employee on your resume and parachute into something better if you want, or pretend this is school: you are learning directly from people like a personal tutor with actual degrees and experience and getting paid to do so.
</p>
</div>
</div>

<div id="outline-container-What%20does%20a%20SWE%2FSDE%20actually%20do" class="outline-3">
<h3 id="What%20does%20a%20SWE%2FSDE%20actually%20do">What does a SWE/SDE actually do</h3>
<div class="outline-text-3" id="text-What%20does%20a%20SWE%2FSDE%20actually%20do">
<p>
In bigtech or other large corporate tech 80% of your work is debugging and 'forensic code analysis' meaning trying to figure out the (gigantic) software that your company bought and a lot of software they use is acquired like Android was by Google or React by Facebook/Meta. This is taught in <a href="./software.html">CS19</a> with property-based testing oracles and example writing. You are a detective writing examples to determine the properties of some undocumented massive software thing and then your testing oracles run to check these properties hold so you can write yet more tests to see if your potential small feature will integrate with the larger systems. You are unlikely to do anything else until you reach some level of trusted experience meaning you achieved multiple promotions, which are very difficult to get because of performance reviews which try and get rid of you yearly or sooner. <i>The work here all depends on which team you land on or are able to request</i> but the reality is you will likely do unchallenging work with little room for advancement, but it's a great place to start and learn directly from people with experience. 
</p>

<p>
In a consulting company like Palantir or Algorithmia you are semi-autonomous and can architect everything yourself but of course this will typically involve existing software so once again 80% debugging and forensic code analysis trying to get client systems to interact with data analysis tools which are themselves gigantic complexity abstractions like Kubernetes (Rubix) or Apache Spark or <a href="https://www.palantir.com/platforms/foundry/">Foundry</a>. The client seems to always be governments or airlines which all have nightmarish legacy systems but there is opportunity for creativity here trying to squeeze data out of <a href="https://www.sabre.com/insights/tag/airline-solutions/">Sabre</a> or w/e proprietary system they're using, or write optimizations. There's ability here for rapid advancement, if you are competitive this seems a better deal than bigtech as you have more personal control over your destiny than some arbitrary performance review because you didn't write enough commits in one month out of 12 or something equally silly.
</p>

<p>
In a specialty Fintech company like Two Sigma or Jane Street advancement is much more likely than bigtech and your work much more challenging squeezing out all the performance you can while still following regulatory requirements like real time updates to some government trading agency. If your work here has company impact, you get a (huge) bonus and opportunity to put that huge bonus into the company's private fund(s). There is much more personal responsibility than bigtech, if you make a mistake with some portfolio optimizer it could cost millions per second so correct and cautious code while still maintaining optimization at NYSE competitive trading speed. The hours can be very long because often data arrives from some proprietary source after end of trading day, and is dumped in terabytes. Think 100+ proprietary (meaning, you have to pay huge money for them) firehoses of data that all need to be checked for integrity (trades stamped after market closing) and prepared so Quants can use them for strategy analysis and backtesting. Everything from custom UIs to rewriting an email exchange server from scratch to helping a Quant translate a Python model into high speed code for market entrancy the next or that trading day. Getting an interview here is not as hard as you think, as it's getting more difficult and expensive to recruit directly from schools as bigtech swoops in and poaches all the grads with their lesser working hours, casual scooter riding campuses and bigger base salaries. Sometimes these Fintech outfits can set up shop on campus and directly recruit and many times they can't, bigtech signs some deal with the university to be the exclusive recruiters beside the usual government agencies, or otherwise schemes to lock competition for new grads out. Passing the interviews is of course harder than anything else, that's why this workshop exists.     
</p>

<p>
In a startup you get to architect it all from scratch together but they won't even look at you unless you have all of the above on your portfolio or you come recommended, like your coworkers at Amazon take off to make their own product and take you with them otherwise you aren't getting in without experience or credentials from a school unless you know somebody and can be recommended, and usually the way to know somebody is go to a school or work with them before they take off to found a startup.
</p>

<p>
In a research programming environment, which is where I started, you get to design from scratch and are attached to a post-doc research group that usually doesn't care at all what you do so long as it works correctly and is done on time/budget. You are basically the CTO. A lot of work here is focused on reproducibility using archaic libraries like Fortran libraries because some paper in the past used the same library and wrote all their proofs with that library, you want to replicate those proofs for some minor part of the bigger thing they are trying to accomplish so testing for exact replication is key then you get to hack your face off doing whatever you want. Getting into this work usually just requires applying from a university careers page, no students apply because they are off chasing highly paid internships instead. The pay is low but it's enough to live comfortably within means, the work totally fascinating and you may even get a letter of recommendation from a PhD after which means gradschool is that much more easier to get into if that's what you want. You still have to pass a technical interview that may even cover design so again, you will still need this workshop.
</p>
</div>
</div>


<div id="outline-container-Why%20not%20leetcode" class="outline-3">
<h3 id="Why%20not%20leetcode">Why not leetcode</h3>
<div class="outline-text-3" id="text-Why%20not%20leetcode">
<p>
Because it costs money to get the good problems, while competitive programming is free and much more interesting. The hardest problems on free tier leetcode are rated about 3.6 of 10 on Kattis, the online judge we will use for problems. As an example: the median of Two Sorted Arrays is rated a hard problem on <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">free-tier</a> leetcode. On Kattis this same problem exists except it is <a href="https://open.kattis.com/problems/continuousmedian">continuous</a>. As the difficulty increases you have to modify/use multiple algorithms and data structures to solve codeforces or kattis problems. Competitive programming online judges will run an enormous amount of tests on your solutions and bound their runtime as well with unlimited submissions. The problems are similar in goal to math olympiad problems, the idea is that you really learn the art of problem solving to apply it to everything in life like open problems in theoretical CS research not only for the purposes of getting hired somewhere. Universities also have courses that use Kattis for assignments like <a href="https://algo.is/competitive-programming-course/">Reykjavik University</a> or <a href="https://nus.kattis.com/">NUS</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-Materials" class="outline-2">
<h2 id="Materials">Materials</h2>
<div class="outline-text-2" id="text-Materials">
<ul class="org-ul">
<li>The <a href="https://cpbook.net/details?cp=4">book</a> <i>Competitive Programming 4</i> (the first volume, 4 chapters), which is around 260 pages and was written both for passing technical interviews and for anybody interested in beginning competitive programming as the author is the coach of Singapore's ICPC/IOI team. Everything we learn we practice with the <a href="https://open.kattis.com/">Kattis Problem Archive</a> and some other online judges, so producing working code for hundreds of problems and submitting them for tests of correctness and problem runtime constraints. Kattis also hosts the ICPC <a href="https://icpc.kattis.com/problems">archive</a> problems which when we're done if you're interested we'll try and <a href="http://www.cs.cmu.edu/~15850/notes/cmu850-f20.pdf">do those too</a>. Kattis even hosts the NSA <a href="https://nsachallenge20.kattis.com/problems">challenges</a>. You don't have to buy this book but it's recommended.</li>

<li>The <a href="https://cseweb.ucsd.edu/~dakane/CSE101/">course</a> CSE101 with open lectures from UCSD taught by IMO gold medalist and four time(!) Putnam fellow <a href="https://en.wikipedia.org/wiki/Daniel_Kane_(mathematician)">Daniel Kane</a> who's algorithms course I stumbled on by accident while looking up his Putnam seminar. This follows the book <a href="https://cseweb.ucsd.edu/~dasgupta/book/index.html">DPV</a> that most universities still use, and the course has a huge amount of problems and worked solutions so we can practice and learn the art of estimating and proving complexity bounds of programs.</li>
</ul>

<p>
We will also do some of:
</p>

<ul class="org-ul">
<li><a href="https://visualgo.net/en">VisuAlgo</a> the visualizations of the algorithms in the CP4 book</li>
<li>The computational geometry lectures from CMU's 15-451 <i>Algorithms</i> undergrad <a href="https://www.cs.cmu.edu/~15451-f20/schedule.html">course</a> (a mix of sp20 and f20) because we have access to the fall 2020 recitations and some spring 2020 lectures.</li>
<li>Relevant chapters from <i>The Art of Computer Programming</i> series as casual reading</li>
</ul>

<p>
We will also do system design, if you've done CS19 you're already familiar with this but here we will go over examples of other software design and also learn how to spot code review flags, so you don't get them. 
</p>
</div>

<div id="outline-container-Backups" class="outline-3">
<h3 id="Backups">Backups</h3>
<div class="outline-text-3" id="text-Backups">
<p>
These are only needed if the public online resources disappear
</p>

<ul class="org-ul">
<li>A <a href="http://btcache.me/torrent/D3B621E29F1C4647E37E5111A1B28FDB790BB056">torrent</a> backup of CSE101 including all the practice exams/solutions and recorded lectures</li>
<li>A <a href="http://btcache.me/torrent/A898A215DDF9FA5E2BAF3F160EA2E9CC41128A04">torrent</a> backup of some 15-451 content, we won't do it all (only computational geometry)</li>
</ul>
</div>
</div>

<div id="outline-container-Languages" class="outline-3">
<h3 id="Languages">Languages</h3>
<div class="outline-text-3" id="text-Languages">
<p>
The book has a public code <a href="https://github.com/stevenhalim/cpbook-code">repository</a> of all the algorithms contained in it, and explains the complexity of the standard libraries for OCaml, Python 3, Java 11 and C++17 but you can use any of <a href="https://open.kattis.com/help">these</a> languages/compiler versions. Pick whatever you personally like from the list of Kattis supported languages though if you're doing this to pass some interview, choose a language hackerrank/codility or coderpad supports as phone screeners and interviewers tend to use those. Some languages like Rust people have reported having problems with the ownership abstraction while using it for competition programming, decide for this yourself of course maybe they don't know what they are doing. Whatever you choose guaranteed there is a tutorial for using it for competitive programming like this <a href="https://byorgey.wordpress.com/2019/04/24/competitive-programming-in-haskell-basic-setup/">Haskell</a> example.
</p>

<p>
If you're using a phone, there are some offline interpreters/compilers you can install from whatever app store your phone is compatible with of varying quality or try the free version of <a href="https://replit.com/">repl.it</a>. You submit to Kattis for judging by pasting in the source code through a web editor, uploading a source file(s) or write a script to automate this using their API. You get unlimited judging submissions.
</p>
</div>

<div id="outline-container-Kotlin" class="outline-4">
<h4 id="Kotlin">Kotlin</h4>
<div class="outline-text-4" id="text-Kotlin">
<p>
Since ICPC allows for Kotlin submissions now, and it's syntax is very similar to Pyret including <a href="https://kotlinlang.org/docs/functions.html#generic-functions">generic type variabless</a>, if you did any of the CS19 workshop you intuitively already know Kotlin. There is even a Kotlin official doc for <a href="https://kotlinlang.org/docs/competitive-programming.html">competitive programming</a>. This is the language I will use.
</p>
</div>
</div>
</div>

<div id="outline-container-Real%20contests" class="outline-3">
<h3 id="Real%20contests">Real contests</h3>
<div class="outline-text-3" id="text-Real%20contests">
<p>
We can compete on CodeForces, <a href="https://icfpcontest2021.github.io/index.html">ICFP</a>, Topcoder, Google Kickstart, Facebook Hacker Cup, <a href="https://code.golf/">Code Golf</a>, <a href="https://microcorruption.com/login">microcorruption</a> or <a href="https://cryptopals.com/">cryptopals</a> type challenges, most of which we have no hope of winning of course but it's practice to pick up more experience. Apply for a job and the interview is another live contest, you win a signing bonus and salary. If you lose who cares find another interview.
</p>
</div>
</div>

<div id="outline-container-An%20example%20competitive%20programming%20class" class="outline-3">
<h3 id="An%20example%20competitive%20programming%20class">An example competitive programming class</h3>
<div class="outline-text-3" id="text-An%20example%20competitive%20programming%20class">
<p>
There's a good writeup <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">here</a> of an exchange student from Canada who took CS 3233 in Singapore and how the author of the cp4 book organizes those classes. It's a 12 day course expanded to 4 months. He recommends learning to modify existing algorithms instead of using fancy data structures.
</p>
</div>
</div>
</div>

<div id="outline-container-Begin" class="outline-2">
<h2 id="Begin">Begin</h2>
<div class="outline-text-2" id="text-Begin">
<p>
I assume you either downloaded the book <i>Competitive Programming 3</i> from library genesis or bought the 4th edition for $20, it's handbook sized and worth the money as it has a ton of solved exercises just in the book itself let alone the hundreds+ of UVa/Kattis problems it recommends doing. The book has several languages as well, Bulgarian and Spanish for the 4th edition and I believe Korean and Spanish for the 3rd edition.
</p>

<p>
This book is designed to be read several times, you work through it once then go back and solve the exercises in each chapter, as they won't make sense the first time around. The author(s) are very blunt in saying if you want to compete, you should know everything in this book and be able to solve many of these problems in under 30 minutes, if very competitive under 10 minutes. You get to that level through practice and always trying to work just above your skill level so you are always advancing. 
</p>
</div>

<div id="outline-container-Preface%20-%20How%20many%20problems" class="outline-3">
<h3 id="Preface%20-%20How%20many%20problems">Preface - How many problems</h3>
<div class="outline-text-3" id="text-Preface%20-%20How%20many%20problems">
<p>
Each chapter topic will have 7 starred 'must try' problems, and all of them are on the site <a href="https://cpbook.net/methodstosolve">methods to solve</a> and that site is more up to date than the book, it's the site we will use so if you don't buy the 4th edition, you're fine. It contains a mix of onlinejudge.com (formerly called UVa) and Kattis problem sets, the bold problem titles are the recommended problems. Hints how to solve them are on the right-hand side if you haven't figured it out but the book explains that's how the authors solved them, but there could be other ways. The CP4 book 1 satisfies the majority of the 2020 IOI syllabus (and also 2021 syllabus since 2020 was virtual/cancelled, even ICPC 2021 changed to March 2022).  
</p>

<p>
The main changes between this book and CP3 is on the book website, such as rearranging some chapters from book 2 to book 1 for the new IOI syllabus, deleting outdated problem categories and including new ones like NP-hard, NP-complete problems. OCaml added as a language, Tezos I believe has sponsored OCaml for the book. CMU's current prof of 15-451 designed their original 15-295 competitive programming seminar, and IIRC most of his code there was in OCaml as well. You could do this book in 2 different languages, 1 language for UVa/onlinejudge problems (C89, C++98, Pascal, Java, C++11 or Python 3) and Kattis accepts many more languages, like OCaml or Haskell (check compiler version). 
</p>

<p>
IOI is presently Python/Java/C++ and ICPC regionals only C/C++, with the ICPC world finals now accepting Kotlin, C/C++, Java and Python with no guarantee the problems can be solved in all the languages as judges only use Java and C/C++ to write solutions. What this means is your solution in Kotlin or Python <i>may</i> exceed the time and resource constraints to get accepted verdict as none of the judges have tried, not that it's impossible to solve in those languages.  
</p>
</div>

<div id="outline-container-Total%20problems" class="outline-4">
<h4 id="Total%20problems">Total problems</h4>
<div class="outline-text-4" id="text-Total%20problems">
<p>
If we only do the starred problems listed on <a href="https://cpbook.net/methodstosolve">methods to solve</a> how many are we looking at? Chapter 4 has 167, 3 has 195, 2 has 165 and the first chapter has 182 or <b>709 total problems</b>. Most problems will be in the 3 to 6 difficulty range with mid-3 difficulty being classified as 'hard' on leetcode (if using free tier leetcode). If you read the above example class writeup of that exchange student, he solved <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">50 problems a day</a> when first started and gained 500 points on Kattis in 2 months, which is the entrance requirement for the course, then he gained 1000 more points on Kattis during his 4 month course in Singapore (noting another student gained 3500 points in 4 months) so this isn't impossible to do.
</p>
</div>
</div>
</div>

<div id="outline-container-Chapter%201" class="outline-3">
<h3 id="Chapter%201">Chapter 1</h3>
<div class="outline-text-3" id="text-Chapter%201">
<p>
Most of this hasn't changed since CP3, this is a casual read. 1.3.2 problem solving skills are mentioned, many of which were taught in <a href="./software.html">CS19</a>. 1.3.3 modern (2020) CPUs can process 10<sup>8</sup> or 100M operations in a second for our solutions, on average, so they recommend to pay attention to bounds if your algorithm is n<sup>4</sup> in complexity but the input is only 50 max, you could still pass the online judge tests. The book notes that we should already have the skills to judge the runtime complexity of our own algorithms, which CSE101 will teach us as we go. 1.3.4 talks about programming languages, how factorial of 40 is trivial in Python but difficult in C/C++, and requires a special library BigInteger in Java. The point being you should know multiple languages enough to be able to solve any problem with them. Really if you look at imperative languages at the forest level instead of the trees, they're all just reinvented ALGOL60 with some kind of dynamic dispatch, this is detailed in Robert Harper's pfpl <a href="http://www.cs.cmu.edu/~rwh/pfpl/">book</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-Problem%20solving%20walkthrough" class="outline-2">
<h2 id="Problem%20solving%20walkthrough">Problem solving walkthrough</h2>
<div class="outline-text-2" id="text-Problem%20solving%20walkthrough">
<p>
Here is Gennady Korotkevich aka tourist <a href="https://youtu.be/97tieEKfvBs">practicing</a> on codeforces and explaining what he's doing, though he didn't start with C++ he used to win the IOI with Pascal. A good article about him is <a href="http://is.ifmo.ru/articles_en/2017/4-17_eng.pdf">here</a> which explains the spartan background, he chooses to live in a student dorm. At school he gives lectures on discrete math/combinatorics and complexity theory which makes sense, if you are a problem solver with code you are likely interested in trying to figure out unsolved problems in theoretical cs. 
</p>

<p>
The first thing to notice is he's using a generic text editor and unusual shell that looks like minimalist GNU for Windows(<a href="https://mingw.osdn.io/">MinGW</a>) and a text mode <a href="https://www.farmanager.com/screenshots.php?l=en">file manager</a> and manually submitting through the codeforces website UI. He prepares individual directories named after the problem, then always makes a sol.cpp file in that directory to use a macro he's written for compiler flags in order to compile the solution, again manually from the shell. 
</p>

<p>
He has a simple C++ template:
</p>
<pre class="example" id="org4b1f108">
// include every C++ std library and bits library
#include &lt;bits/stdc++.h&gt;

// use std namespace to avoid having to write std::endl or std::cout
using namespace std;

int main() {
// turn off default cout flush
 ios::synch_with_stdio(false);
 cin.tie(0)

while (TT--) {
// while (true) do following..
// way to decrement through the input stream to zero
</pre>

<p>
std::cin is synchronized to std::cout and performs default buffer flushing operations to save runtime. This is all written in online C++ references you can read yourself if you choose to use C++. His compiler flags he explains in one of these Twitch streams, or you can figure out yourself too as you go, most of them are to make compiler messages extra verbose for debugging. 
</p>

<p>
You don't have to watch the entire 2hr vid, the last problem seems like the most informative to watch. He begins most problems by writing himself examples as comments, something we already learned in <a href="./software.html">CS19</a>. He copies the problem input test cases into a text file 'in1' then pipes it into his compiled program "sol.exe &lt; in1" as stdin (standard input). He writes multiple submissions to compare their runtime/memory usage. He looks for some kind of mathematical structure in the formulas given in problem writeup. After he looks up the solutions and compares them to his own.    
</p>

<p>
@1:43:48 or so he reads the writeup for a problem describing local maximum and minimum, which is the chapter on optimization in the calculus book we do <a href="./calculus.html">here</a> if you're interested. In the last problem he get's time limit exceeded verdict and trolls his live stream that replacing all the variable names with a single letter will make it run faster. His solution had nested initialization of numerous vectors inside loops, so everytime they loop you init another vector(s), once he removed those out of the loop he achieved accepted verdict. The judging server ran his program faster than his own laptop, something to remember if debugging and believing your solution still isn't optimized enough. 
</p>
</div>
</div>

<div id="outline-container-CSE101%20Lecture%201" class="outline-2">
<h2 id="CSE101%20Lecture%201">CSE101 Lecture 1</h2>
<div class="outline-text-2" id="text-CSE101%20Lecture%201">
<p>
Watching <a href="https://cseweb.ucsd.edu/~dakane/CSE101/Lec1.html">lecture 1</a>, I'm going to follow this course's topics and match them with the competitive programming book. These topics are presented in CSE101 in this order:
</p>

<ul class="org-ul">
<li>Graphs</li>
<li>Problem solving tools:  
<ul class="org-ul">
<li>Divide &amp; Conquer</li>
<li>Greedy search</li>
<li>Complete search</li>
<li>Dynamic programming</li>
</ul></li>
<li>NP-Completeness</li>
<li>Linear programming</li>
<li>Matrix problems ie: 'determine if there is a vector X in matrix Y' type questions</li>
</ul>

<p>
The first 35 minutes of this lecture are course logistics you may want to watch anyway, he talks about what he expects on the homework (we have all the solutions). This course will use pseudocode that applies to any language. For some reason virtually every algorithms book/course beings with Fib(n) and how slow the easy recursive solution is. You fix it with memoization (caching earlier results), or changing the function to be associative like we learned in CS19, or how Robert Harper terms it 'recursion without reentrancy'.
</p>

<p>
Cut and paste this program <a href="https://code.pyret.org/editor">here</a> it finishes immediately:
</p>

<pre class="example" id="orga635b80">
fun fib(n :: Number) -&gt; Number:
  doc: "Simple Fib(n) without reentry" 

  fun fib-helper(count, prev-1, prev-2):
    if count &lt;= 0:
      prev-1
    else:
      fib-helper(count - 1, (prev-1 + prev-2), prev-1)
    end
  end
  
  fib-helper(n - 2, 1, 1)
where:
  fib(300) is 222232244629420445529739893461909967206666939096499764990979600 
  fib(100) is 354224848179261915075
  fib(11) is 89 
  fib(9) is 34
  fib(5) is 5
  fib(4) is 3
  fib(3) is 2
  fib(2) is 1
  fib(1) is 1
end
</pre>

<p>
In the lecture he uses an array to store previous results as a caching example, this is just a demo we aren't supposed to memorize what he's doing. It's meant to reinforce 'what exactly is the complexity of initializing an array, how does this work at the machine implementation level' meaning that could be an O(1) constant operation in some languages.
</p>

<p>
TODO day 1 and hw
</p>



<hr>
<p>
<a href="./index.html">Home</a>
</p>
</div>
</div>
</div>
</body>
</html>
