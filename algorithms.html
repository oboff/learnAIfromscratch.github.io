<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-11-18 Thu 07:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Competitive Programming for Programming Interviews</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  body {
  max-width: 40rem;
  padding: 1rem;
  margin: auto;
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {background-color: #fafad2} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Competitive Programming for Programming Interviews</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#What%20is%20this">What is this</a>
<ul>
<li><a href="#Why%20wagie%20slaving">Why wagie slaving</a></li>
<li><a href="#What%20does%20a%20SWE%2FSDE%20actually%20do">What does a SWE/SDE actually do</a></li>
<li><a href="#Why%20not%20leetcode">Why not leetcode</a></li>
</ul>
</li>
<li><a href="#Materials">Materials</a>
<ul>
<li><a href="#Backups">Backups</a></li>
<li><a href="#Languages">Languages</a></li>
<li><a href="#Using%20a%20phone%2Ftablet">Using a phone/tablet</a></li>
<li><a href="#Real%20contests">Real contests</a></li>
<li><a href="#An%20example%20competitive%20programming%20class">An example competitive programming class</a></li>
<li><a href="#An%20example%20problem%20solving%20walkthrough">An example problem solving walkthrough</a></li>
</ul>
</li>
<li><a href="#Begin">Begin</a>
<ul>
<li><a href="#Preface%20-%20How%20many%20problems">Preface - How many problems</a></li>
<li><a href="#Chapter%201">Chapter 1</a></li>
<li><a href="#Methods%20to%20solve">Methods to solve</a></li>
<li><a href="#Kotlin">Kotlin</a></li>
</ul>
</li>
<li><a href="#Asymptotics">Asymptotics</a>
<ul>
<li><a href="#Computational%20model">Computational model</a></li>
<li><a href="#Logarithms">Logarithms</a></li>
<li><a href="#Math%20model">Math model</a></li>
<li><a href="#CS%20Theory%20Toolkit%20lecture%202">CS Theory Toolkit lecture 2</a></li>
<li><a href="#CS%20Theory%20toolkit%20lecture%203">CS Theory toolkit lecture 3</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-What%20is%20this" class="outline-2">
<h2 id="What%20is%20this">What is this</h2>
<div class="outline-text-2" id="text-What%20is%20this">
<p>
This is a game, where I study the same material you do then take mass interviews myself to prove the material will work for any other anon anywhere on earth. The focus is on understanding asymptotics so you can teach yourself for the most part, then practicing writing software in competitive programming. This is a draft, a first iteration of TA style notes that will be something else later, maybe even an actual game.       
</p>

<p>
This will include system design and is targeted to Palantir and Amazon, since they have recruiters everywhere and hire developers for US, Canada, India, Germany, UK, Ireland, Spain, China, Luxembourg, Poland, South Africa, Israel, Taiwan, Romania, Jordan, Australia, Netherlands, Japan, Mexico, Costa Rica, France, New Zealand, Italy, Arab Emirates, Egypt, Sweden, Finland, Chile, Austria, Greece (they pay to relocate to Luxembourg) and probably a few countries I left out as I'm only going off the current vacancies on their websites. Do you live in or can get to one of those countries and want to get paid to write software with no academic background whatsoever? Read on.
</p>
</div>

<div id="outline-container-Why%20wagie%20slaving" class="outline-3">
<h3 id="Why%20wagie%20slaving">Why wagie slaving</h3>
<div class="outline-text-3" id="text-Why%20wagie%20slaving">
<p>
If you do not have experience or some kind of formal accreditation it is unlikely you will even be able to bypass the AI resume filter elsewhere whereas at Amazon or Palantir, you just need to pass the (difficult) interviews and you're in, as they have an army of recruiters always looking for new hires. The day you are hired you are free to drop Amazon employee on your resume and parachute into something better if you want, or pretend this is school: you are learning directly from people like a personal tutor with actual degrees and experience and getting paid to do so. 
</p>
</div>
</div>

<div id="outline-container-What%20does%20a%20SWE%2FSDE%20actually%20do" class="outline-3">
<h3 id="What%20does%20a%20SWE%2FSDE%20actually%20do">What does a SWE/SDE actually do</h3>
<div class="outline-text-3" id="text-What%20does%20a%20SWE%2FSDE%20actually%20do">
<p>
As a new hire in bigtech or other large corporate tech 80% of your work is debugging and 'forensic code analysis' meaning trying to figure out the (gigantic) software that your company bought and a lot of software they use is acquired like Android was by Google or React by Facebook/Meta. You are unlikely to do anything else until you reach some level of trusted experience meaning you achieved multiple promotions, which are very difficult to get because of performance reviews which try and get rid of you yearly or sooner. The work here all depends on which team you land on or are able to request but the probability is high you will do unchallenging work with little room for advancement, but it's a great place to start and learn directly from people with experience. This is where you can meet other to help form a startup too. 
</p>

<p>
In a consulting company like Palantir you are semi-autonomous and can architect everything yourself but of course this will typically involve existing frameworks/massive software libraries so once again 80% debugging and forensic code analysis trying to get client systems to interact with data analysis tools which are themselves gigantic complexity abstractions like Kubernetes (Rubix) or Apache Spark or <a href="https://www.palantir.com/platforms/foundry/">Foundry</a>. The client seems to always be governments or airlines, so nightmarish legacy systems but there is opportunity for creativity here trying to write optimizations or squeeze data out of <a href="https://www.sabre.com/insights/tag/airline-solutions/">Sabre</a> or w/e proprietary system airlines are still using. Advancement here is easier than any large tech company, if you are competitive this seems a better deal than bigtech as you have more personal control over your destiny than some arbitrary performance review because you didn't write enough commits in one month out of 12 or something equally silly. 
</p>

<p>
In a specialty Fintech company like Two Sigma or Jane Street advancement is again much more likely than bigtech and your work much more challenging squeezing out all the performance you can while still following regulatory requirements like real time updates to some government trading agency, harder to engineer than it sounds. If your work here has company impact, you get a (huge) bonus and opportunity to put that huge bonus into the company's private fund(s). There is much more personal responsibility than bigtech, if you make a mistake with some portfolio optimizer it could cost millions per second so correct and cautious code while still maintaining optimization at NYSE competitive trading speed, however they don't care in the beginning if you don't know that level of optimization they only care you can write correct code. The hours can be very long because often data arrives from some proprietary source after end of trading day, and is dumped on you in terabytes. Think 100+ proprietary (meaning, you have to pay huge money for them) firehoses of data that all need to be checked for integrity (trades time stamped after market closing) and prepared so Quants can use them for strategy analysis and backtesting. Everything from rewriting an email exchange server from scratch, writing customer bid/ask or visualization software, writing your own Bloomberg terminal-like clone, or even helping a Quant translate a Python or Mathematica model into high speed code for market entrancy the next or that trading day. Getting an interview here is not as hard as you think, as it's becoming more difficult and expensive to recruit directly from schools as bigtech swoops in and poaches all the grads with their lesser working hours, casual scooter riding campuses and bigger base salaries (little do they know, end of the year they're gone). Sometimes these Fintech outfits can set up shop on campus and directly recruit and many times they can't because bigtech signs some deal with the university to be the exclusive recruiters beside the usual government agencies, or otherwise schemes to lock competition for new grads out. This means opportunity for you to slither on in but passing the interviews is of course harder than anything else, that's why this workshop exists.     
</p>

<p>
In a startup you get to architect it all from scratch together but they won't risk hiring you unless you have all of the above on your portfolio or you come recommended ie: your coworkers at Amazon take off to make their own thing and take you with them. Of course you can make your own startup but that requires money to live off while you dedicate your time building something with no income. If you need to hire somebody, how do you know if they're any good if you don't know basic system and algorithm design yourself? This is another reason why this workshop exist, save up money working and take a year or two off to do something you always wanted to try. 
</p>

<p>
In a research programming environment, which is where I started, you get to design from scratch and are attached to a post-doc research group that usually doesn't care at all what you do so long as it works correctly and is done on time/budget. You are basically the CTO. A lot of work here is focused on reproducibility using archaic libraries like Fortran libraries because some paper in the past used the same library and wrote all their proofs with that library, you want to replicate those proofs for some minor part of the bigger thing they are trying to accomplish so testing for exact replication is key then you get to hack your face off doing whatever you want. Getting into this work usually just requires applying from a university careers page, no students apply because they are off chasing highly paid internships instead. The pay is low but it's enough to live comfortably within means, the work totally fascinating and you may even get a letter of recommendation from a PhD after which means gradschool is that much more easier to get into if that's what you want. You still have to pass a technical interview that may even cover design so again, you will still need this workshop.
</p>
</div>

<div id="outline-container-Part-time" class="outline-4">
<h4 id="Part-time">Part-time</h4>
<div class="outline-text-4" id="text-Part-time">
<p>
Send out a firehose of applications and indicate you can only work part-time, somebody may bite. There is also <a href="https://mobilejazz.com/careers/">mobilejazz.com</a> who hires P/T Kotlin and other remote developers or <a href="https://4dayweek.io/">4dayweek.io</a>. Toptal I have worked for briefly in the past, at the end of a contract you can screw off for a few months or take a P/T contract but I have no idea the present state of working there this was years ago. 
</p>
</div>
</div>
</div>

<div id="outline-container-Why%20not%20leetcode" class="outline-3">
<h3 id="Why%20not%20leetcode">Why not leetcode</h3>
<div class="outline-text-3" id="text-Why%20not%20leetcode">
<p>
Because it costs money to get the good problems, while competitive programming is free and much more interesting. The hardest problems on free tier leetcode are rated about 3.6 of 10 on Kattis, the online judge we will use for problems. As an example: the median of Two Sorted Arrays is rated a hard problem on <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">free-tier</a> leetcode. On Kattis this same problem exists except it is a <a href="https://open.kattis.com/problems/continuousmedian">continuous</a> variant. The problems we will eventually do are similar in goal to math olympiad problems, the idea is that you really learn the art of problem solving to apply it to everything in life like open problems in theoretical CS research. Universities also have courses that use Kattis for assignments like <a href="https://algo.is/competitive-programming-course/">Reykjavik University</a> or <a href="https://nus.kattis.com/">NUS</a> or <a href="https://kth.kattis.com/courses/DD2458">KTH</a> Stockholm university 'programming under pressure' course. 
</p>
</div>
</div>
</div>

<div id="outline-container-Materials" class="outline-2">
<h2 id="Materials">Materials</h2>
<div class="outline-text-2" id="text-Materials">
<p>
Every book listed here is free from <a href="https://en.wikipedia.org/wiki/Library_Genesis">Library Genesis</a> or search WorldCat library if you can't buy them
</p>

<ul class="org-ul">
<li>The <a href="https://cpbook.net/details?cp=4">book</a> <i>Competitive Programming 4</i> (the first volume, 4 chapters)</li>
</ul>

<p>
The first volume was written both for passing technical interviews and for anybody interested in beginning competitive programming as the author is the coach of Singapore's ICPC/IOI team. Practice is done with the <a href="https://open.kattis.com/">Kattis Problem Archive</a> and some other online judges, so producing working code for hundreds of problems and submitting them for tests of correctness and problem runtime constraints. Kattis also hosts the ICPC <a href="https://icpc.kattis.com/problems">archive</a> problems which when we're done if you're interested we'll try and <a href="http://www.cs.cmu.edu/~15850/notes/cmu850-f20.pdf">do those too</a>. Kattis even hosts the NSA <a href="https://nsachallenge20.kattis.com/problems">challenges</a>. All the algorithms have visualizations on the author's site <a href="https://visualgo.net/en">VisuAlgo</a>.
</p>

<ul class="org-ul">
<li>MIT's <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2020/">6.006</a> sp2020 course on OCW w/open lectures</li>
</ul>

<p>
Contains full problem walkthroughs. I preferred this course to others because they actually use a board, instead of zoom slides so you can see problems being fully worked out. We have access to everything and it's permanent so won't disappear behind logins. You probably won't need to watch/do most of this course.
</p>

<ul class="org-ul">
<li>Other materials to fill in gaps</li>
</ul>

<p>
Some from: UCSD's CSE101 <a href="https://cseweb.ucsd.edu/~dakane/CSE101/">course</a>, Ryan O'donnell's <a href="https://www.youtube.com/playlist?list=PLm3J0oaFux3ZYpFLwwrlv_EHH9wtH6pnX">CS Theory Toolkit</a>, CMU's 15-451 <i>Algorithms</i> undergrad <a href="https://www.cs.cmu.edu/~15451-f20/schedule.html">course</a> to learn FFT/Computational Geometry, and 15-295 <i>Competitive Programming</i>. The <a href="https://cs.nyu.edu/~spencer/">book</a> <i>Asymptopia</i> by Spencer and <a href="https://cseweb.ucsd.edu/~dasgupta/book/index.html">DPV</a> which we'll do very few parts of each. CMU's <i>Parallel &amp; Sequential Algorithms</i> <a href="https://www.diderot.one/courses/89">book</a>. We will also study software architecture <a href="https://www.worldcat.org/title/system-design-interview-an-insiders-guide-second-edition/oclc/1253363956&amp;referer=brief_results">examples</a>. 
</p>
</div>

<div id="outline-container-Backups" class="outline-3">
<h3 id="Backups">Backups</h3>
<div class="outline-text-3" id="text-Backups">
<p>
These are only needed if the public online resources disappear
</p>

<ul class="org-ul">
<li>CSE101 <a href="https://btcache.me/torrent/D3B621E29F1C4647E37E5111A1B28FDB790BB056">torrent file</a> contains recorded lectures, all assignments/solutions and past exams/solutions, didn't add the exam review lectures.</li>

<li>15-451 <a href="https://btcache.me/torrent/A898A215DDF9FA5E2BAF3F160EA2E9CC41128A04">torrent file</a> some recorded lectures &amp; recitations</li>
</ul>
</div>
</div>


<div id="outline-container-Languages" class="outline-3">
<h3 id="Languages">Languages</h3>
<div class="outline-text-3" id="text-Languages">
<p>
The book has a public code <a href="https://github.com/stevenhalim/cpbook-code">repository</a> of all the algorithms contained in it, and explains the complexity of the standard libraries for OCaml, Python 3, Java 11 and C++17 but you can use any of <a href="https://open.kattis.com/help">these</a> languages. You don't have to use that specific compiler version for your local system, just be aware of any differences in versions when you make a submission not using some feature that doesn't exist yet in the Kattis version. Whatever language you choose guaranteed there is a tutorial for using it for competitive programming like this <a href="https://byorgey.wordpress.com/2019/04/24/competitive-programming-in-haskell-basic-setup/">Haskell</a> example.
</p>

<p>
Some languages like Rust or Python, people claim it can't be done because Python is 'too slow' or for Rust the ownership abstraction thing they use makes manipulating linked lists impossible. You should decide for yourself, or use numerous languages the book author considers competency in Python for string manipulation problems, competency in Java for using specialty libraries like GregorianCalendar or BigInteger, and competency in C++ to be a successful competitive programmer so you don't have to use only one language. In machine learning labs using Python they <a href="https://rushter.com/blog/python-garbage-collector/">disable the GC</a> and it's possible to make everything unsafe in Rust if you want for manipulating memory with abandon, we are hacking solutions here by any means necessary for fun and profit so be creative digging into the language docs to break anything in your way to accepted verdict glory.  
</p>

<p>
Here are the rules of the ICPC world finals and the <a href="https://docs.icpc.global/worldfinals-programming-environment/">languages</a> they allow, though judges only guarantee solutions with passing tests in C++ and Java, but it doesn't mean you can't have AC verdict with other languages.
</p>
</div>
</div>


<div id="outline-container-Using%20a%20phone%2Ftablet" class="outline-3">
<h3 id="Using%20a%20phone%2Ftablet">Using a phone/tablet</h3>
<div class="outline-text-3" id="text-Using%20a%20phone%2Ftablet">
<p>
Looking around the Android store, the only decent offline app seems to be a <a href="https://youtu.be/FeWBu9Gf-Rs">Pascal</a> compiler made by a highschool kid in Vietnam. Both Kattis and onlinejudge.org accept Pascal submissions (I think the IOI still accepts it) and Pascal is imperative pseudocode, simple to learn. If you want an online compiler there are many options like <a href="https://replit.com/">Repl.it</a> which MIT uses in their lectures. 
</p>

<p>
If you must you can use any text editor and since competitive programming online judges accept unlimited submissions you can submit source and let Kattis compile your programs. Debugging is going to be on maximum hard mode however, like back in the 60s when Knuth had only P/T access to a system so had to debug his code by hand stepping through the logic before being allowed to actually run it and verify it worked.  
</p>
</div>
</div>

<div id="outline-container-Real%20contests" class="outline-3">
<h3 id="Real%20contests">Real contests</h3>
<div class="outline-text-3" id="text-Real%20contests">
<p>
We can compete on CodeForces, <a href="https://icfpcontest2021.github.io/index.html">ICFP</a>, Topcoder, Google Kickstart, Facebook Hacker Cup, <a href="https://code.golf/">Code Golf</a>, <a href="https://microcorruption.com/login">microcorruption</a> or <a href="https://cryptopals.com/">cryptopals</a> type challenges, most of which we have <i>no hope of winning</i> of course but it's practice to pick up more experience. 
</p>
</div>
</div>

<div id="outline-container-An%20example%20competitive%20programming%20class" class="outline-3">
<h3 id="An%20example%20competitive%20programming%20class">An example competitive programming class</h3>
<div class="outline-text-3" id="text-An%20example%20competitive%20programming%20class">
<p>
A great writeup <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">here</a> of an exchange student from Canada who took CS 3233 in Singapore and how the author of the cp4 book organizes those classes. It's a 12 day course expanded to 4 months as most of the work is the class competing against each other. He recommends learning to modify existing algorithms instead of using fancy data structures.
</p>
</div>
</div>

<div id="outline-container-An%20example%20problem%20solving%20walkthrough" class="outline-3">
<h3 id="An%20example%20problem%20solving%20walkthrough">An example problem solving walkthrough</h3>
<div class="outline-text-3" id="text-An%20example%20problem%20solving%20walkthrough">
<p>
Here is Gennady Korotkevich aka tourist <a href="https://youtu.be/97tieEKfvBs">practicing</a> on codeforces and explaining what he's doing, though he didn't start with C++ he used to win the IOI with Pascal. A good article about him is <a href="http://is.ifmo.ru/articles_en/2017/4-17_eng.pdf">here</a> which explains the spartan background, he chooses to live in a student dorm. At school he gives lectures on discrete math/combinatorics and complexity theory which makes sense, if you are a master problem solver you are likely interested in trying to figure out unsolved problems in theoretical cs. 
</p>

<p>
The first thing to notice is he's using a generic text editor and unusual shell that looks like minimalist GNU for Windows(<a href="https://mingw.osdn.io/">MinGW</a>) and a text mode <a href="https://www.farmanager.com/screenshots.php?l=en">file manager</a> and manually submitting through the codeforces website UI. He prepares individual directories named after the problem, then always makes a sol.cpp file in that directory so he doesn't have to change a macro he's written to compile the solution from the shell. 
</p>

<p>
His C++ template:
</p>
<pre class="example" id="org955ba7c">
// include every C++ std library and bits library
#include &lt;bits/stdc++.h&gt;

// use std namespace to avoid having to write std::cin or std::cout
using namespace std;

int main() {
// turn off default cout flush
 ios::synch_with_stdio(false);
 cin.tie(0)

while (TT--) {
// while (true) do following..
// way to decrement through the input stream to zero
</pre>

<p>
std::cin is synchronized to std::cout and performs default buffer flushing operations, so to save runtime he disables this sync. This is all written in online C++ references you can read yourself if you choose to use C++. His compiler flags he explains in one of these Twitch streams, or you can figure out yourself too as you go, most of them are to make compiler messages extra verbose for debugging. 
</p>

<p>
You don't have to watch the entire 2hr vid, the last problem seems like the most informative. He begins most problems by writing himself examples as comments, something we already learned in <a href="./software.html">CS19</a>. He copies the problem input test cases into a text file 'in1' then pipes it into his compiled program "sol.exe &lt; in1" as stdin (standard input). He writes multiple submissions to compare their runtime/memory usage. He looks for some kind of mathematical structure in the formulas given in the problem writeup. After submission he looks up the solutions by the problem writers and compares them to his own.    
</p>

<p>
@1:43:48 or so he reads the writeup for a problem describing local maximum and minimum, which is the chapter on optimization in the calculus book we do <a href="./calculus.html">here</a> if you're interested. In the last problem he get's time limit exceeded verdict and trolls his live stream that replacing all the variable names with a single letter will make it run faster. His solution had nested initialization of numerous vectors inside loops, so everytime they loop you init another vector(s), once he removed those out of the loop he achieved accepted verdict. The judging server ran his program faster than his own laptop, something to remember if debugging and believing your solution still isn't optimized enough. 
</p>
</div>
</div>
</div>

<div id="outline-container-Begin" class="outline-2">
<h2 id="Begin">Begin</h2>
<div class="outline-text-2" id="text-Begin">
<p>
I assume you either downloaded the book <i>Competitive Programming 3</i> from library genesis or bought the 4th edition for $20, it's handbook sized and worth the money as it has a ton of solved exercises just in the book itself let alone the hundreds+ of UVa/Kattis problems it recommends doing. The book has several languages as well, Bulgarian and Spanish for the 4th edition and I believe Korean and Spanish for the 3rd edition.
</p>

<p>
This book is designed to be read several times, you work through it once then go back and solve the exercises in each chapter, as they won't make sense the first time around. The author(s) are very blunt in saying if you want to compete, you should know everything in this book and be able to solve many of these problems in under 30 minutes, if very competitive under 10 minutes. You get to that level through practice and always trying to work just above your skill level so you are always advancing. 
</p>
</div>

<div id="outline-container-Preface%20-%20How%20many%20problems" class="outline-3">
<h3 id="Preface%20-%20How%20many%20problems">Preface - How many problems</h3>
<div class="outline-text-3" id="text-Preface%20-%20How%20many%20problems">
<p>
Each chapter topic will have 7 starred 'must try' problems, and all of them are on the site <a href="https://cpbook.net/methodstosolve">methods to solve</a> and that site is more up to date than the book, it's the site we will use so if you don't buy the 4th edition, you're fine. It contains a mix of onlinejudge.com (formerly called UVa online judge) and Kattis problem sets, the bold problem titles are the recommended problems. Hints how to solve them are on the right-hand side if you haven't figured it out but the book explains that's how the authors solved them, but there could be other ways. The CP4 book 1 satisfies the majority of the 2020 IOI syllabus (and also 2021 syllabus since 2020 was virtual/cancelled, even ICPC 2021 changed to March 2022) and it was designed for passing tech interviews.  
</p>

<p>
If we only do the starred problems listed on <a href="https://cpbook.net/methodstosolve">methods to solve</a> how many are we looking at? Chapter 4 has 167, 3 has 195, 2 has 165 and the first chapter has 182 or <b>709 total problems</b> if you're using both UVa and Kattis. If you read the above example class writeup of that exchange student, he solved <a href="https://imjching.com/writings/2019/06/21/getting-into-competitive-programming/">50 problems a day</a> when first started and gained 500 points on Kattis in 2 months, which is the entrance requirement for the course, then he gained 1000 more points on Kattis during his 4 month course in Singapore (noting another student gained 3500 points in 4 months) so this isn't impossible to do.
</p>
</div>
</div>

<div id="outline-container-Chapter%201" class="outline-3">
<h3 id="Chapter%201">Chapter 1</h3>
<div class="outline-text-3" id="text-Chapter%201">
<p>
Most of this hasn't changed since CP3, this is a casual read. 1.3.2 problem solving skills are mentioned, many of which were taught in <a href="./software.html">CS19</a>. 1.3.3 modern (2020) CPUs can process 10<sup>8</sup> or 100M operations in a second for our solutions, on average, so they recommend to pay attention to bounds if your algorithm is n<sup>4</sup> in complexity but the input is only 50 inputs max, you could still pass the online judge tests. The book notes that we should already have the skills to judge the runtime complexity of our own algorithms, which CSE101 will teach us as we go.
</p>

<p>
1.3.4 talks about programming languages, how factorials like 40! are trivial in Python but difficult in C/C++, and requires a special library BigInteger in Java. The point being you should know multiple languages enough to be able to solve any problem with them. The rest of this chapter will show you how to get your first AC verdict on Kattis, and has multiple examples of how to get and manipulate input which of course are also on the book github repository. 
</p>
</div>
</div>

<div id="outline-container-Methods%20to%20solve" class="outline-3">
<h3 id="Methods%20to%20solve">Methods to solve</h3>
<div class="outline-text-3" id="text-Methods%20to%20solve">
<p>
Here are <a href="https://cpbook.net/methodstosolve?oj=kattis&amp;topic=ch1&amp;quality=starred">97 starred problems</a> from the cp4 book chapter 1, if you are only using Kattis online judge. They are designed to learn basic I/O like input parsing and output formatting in whatever language you pick from <a href="https://open.kattis.com/help">here</a>. If you want even more practice, do both the regular and starred Kattis problems of which there are <a href="https://cpbook.net/methodstosolve?oj=kattis&amp;topic=ch1&amp;quality=all">211</a> on the methods to solve website. If you want to use both Kattis and onlinejudge.org there is <a href="https://cpbook.net/methodstosolve?oj=both&amp;topic=ch1&amp;quality=all">479</a> chapter 1 problems in total for both sites.
</p>
</div>
</div>

<div id="outline-container-Kotlin" class="outline-3">
<h3 id="Kotlin">Kotlin</h3>
<div class="outline-text-3" id="text-Kotlin">
<p>
My language of choice will be Kotlin for the starred problems &amp; Common Lisp for the others:
</p>

<ul class="org-ul">
<li>ICPC <a href="https://docs.icpc.global/worldfinals-programming-environment/">now accepts</a> Kotlin for submissions</li>
<li>Kotlin syntax is so similar to Pyret if you came from CS19 you already know Kotlin</li>
<li>Kotlin seems to be the default AndroidStudio development language</li>
<li>Common Lisp <a href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/#s16-lisp-as-a-system">development process</a> is perfect for this style and I want to try it for the ICPC problems</li>
</ul>

<p>
Our Kotlin source will be compiled to Java bytecode that will be run in the Java Virtual Machine (JVM). There is of course potential problems adding another layer of complexity going from Kotlin -&gt; Java bytecode -&gt; JVM and many things can go wrong or run too slow for some problems though I plan on diving as deep as possible into the bytecode being generated and internals of the JVM for learning purposes anyway. Maybe we can write our own code to tune the how Kattis compiles it, who knows.
</p>

<p>
<b>Overview</b>
</p>

<p>
From the documentation: "Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one" note these unopinionated languages where you can magically program in multiple styles already exist like OCaml.
</p>

<p>
The JVM and Android targets look good at first glance, however the Kotlin Native and other targets seem like hacks. The compilation is slower than default Java and I suspect runs slower in the JVM than plain old Java would as well. Some of the syntax is annoying, like mandatory type annotations for function parameters and you almost have to use the Jetbrains IDE IntelliJ to take advantage of the full features like highlight, generate tests or dissassemble bytecode to java code instantly to check what it's generating. I don't care I'll use their IDE and mainpulate it for speed.  
</p>


<p>
Assuming you came here from CS19 here is what you need to know:
</p>

<p>
<b>Variables/Assignables</b>
var is a mutable assignable, val is immutable. You can use type annotations like val NAME: type
</p>

<p>
<b>Data Types</b>
In Pyret you could make your own data types, in Kotlin you can do the same (I took this from <a href="https://www.raywenderlich.com/9527-functional-programming-with-kotlin-and-arrow-getting-started">Massimo Carli</a>):
</p>

<pre class="example" id="orgda049cd">
data class Price(val value: Double, val currency: String = "$")

data class Book(
  val ISDN: String,
  val name: String,
  val pages: Int,
  val price: Price,
  val weight: Double,
  val year: Int,
  val author: String
)

  val androidBook = Book(
    "8850333404",
    "Android 6: guida per lo sviluppatore (Italian Edition)",
    846,
    Price(39.26, "£"),
    2.1,
    2016,
    "Massimo Carli"
  )
</pre>

<p>
Now androidBook is type Book. 
</p>

<p>
<b>Functions</b>
</p>

<pre class="example" id="orgb2c1801">
fun f(i: Int) = i + i
// no return statement needed
// parameter type annotations mandatory (why? who knows)

fun f(i: Int): Int = i + i
// annotate the return type like -&gt; Number in Pyret   

fun double(i: Int): Int { stuff here }
//  using blocks { }, need a return statement

fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; { stuff here }
//exact same meaning in Pyret, generic type

{ a, b -&gt; a * b}
// lambdas, notice no annotations needed for params   
</pre>

<p>
In Pyret a function that takes another function:
</p>

<pre class="example" id="org9c007a9">
fun g&lt;A, B&gt;(f :: (A, B -&gt; B), i :: A)-&gt; B:
</pre>
<p>
Type annotation f :: (A,B -&gt; B) in Pyret means parameter f is a function that takes two inputs of type A and B, returns type B. It's the same in Kotlin except you have to add details of the function params, so it would look like: fun g&lt;A, B&gt; (f: (input: A, predicate: B) -&gt; B, i: A): B or so, read the documentation and try yourself but you already know this. 
</p>

<p>
<b>Standard Library</b>
</p>

<p>
Is exactly the same as Pyret really, you already <a href="https://kotlinlang.org/docs/collections-overview.html#set">know</a> 'collections' and everything else will be quickly picked up by looking through the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/">standard library</a> while trying the <i>methods to solve</i> cp4 chapter 1, 97 beginner starred problems.
</p>

<p>
Since this will probably take a week to do let's move on to the critical aspect of every algorithm course which is understanding asymptotics. 
</p>
</div>
</div>
</div>

<div id="outline-container-Asymptotics" class="outline-2">
<h2 id="Asymptotics">Asymptotics</h2>
<div class="outline-text-2" id="text-Asymptotics">
<p>
We are leaving the world of precision math for the rest of this workshop and entering the wild and crazy art of asymptotics where we get to estimate everything with slippery definitions. All your time should be spent here understanding how this approximation works then everything else is trivial like working through any algorithm text on your own.
</p>
</div>

<div id="outline-container-Computational%20model" class="outline-3">
<h3 id="Computational%20model">Computational model</h3>
<div class="outline-text-3" id="text-Computational%20model">
<p>
First, if you did not do CS19, then watch <a href="https://youtu.be/-dQAGsSrKBA">this</a> which is lecture 4 of CS19 where Prof K explains a computational model. You can, even if you only know Python or another language, probably figure out the simple Pyret cases syntax which you can interpret as an if-statement: if this link is empty then return 0, if not empty +1 and then call the function again with one less element in the list until we add up the length. There's also a writeup <a href="https://papl.cs.brown.edu/2020/predicting-growth.html#%28part._math-anon-functions%29">here</a> and these <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html">notes</a> have an excellent introduction to the ambiguities of Big-O notation, what a computation model is, what 'running time' means.
</p>

<p>
The MIT 6.006 course we do will explain all this as well.
</p>
</div>
</div>

<div id="outline-container-Logarithms" class="outline-3">
<h3 id="Logarithms">Logarithms</h3>
<div class="outline-text-3" id="text-Logarithms">
<p>
Chapter 0.3 of <i>Algorithms</i> by <a href="https://cseweb.ucsd.edu/~dasgupta/book/index.html">DPV</a> read through it once, then skip to page 12 of 1.1 <i>Basic Arithmetic</i> and read the bases and logs aside if you forgot them. It's still not enough though, procure <i>The Art of Computer Programming, Vol. 1</i> either by <a href="http://library.lol/main/3612CEBCEE66E75A23440B97A1B560DB">library genesis</a> or buy a copy it'll be the best book you'll ever own. Skip to 1.2.2 <i>Numbers, Powers, and Logarithms</i>. We are interested in page 22 and 23, the laws of exponents for integer exponents, and rational exponents, and all the logarithm identities. A log is an exponent, so exactly how you combine exponents is how you manipulate logs ie log(xy) what do you do when you multiply two bases together w/exponents? log(x) + log(y) you add them.
</p>

<p>
Prof K in CS19 also has a nice intuition for logarithmic time, a log is how many zeros a number has. If you input goes from 1 to 1 million, and your algorithm is log n or logarithmic in the number of steps then work increased by a factor of only 6. An algorithm doing logarithmic steps means at every iteration of your algorithm you throw away half the input.  
</p>

<p>
In the <a href="./calculus.html">calculus</a> workshop there's a great chapter and lectures on ln(x) or the 'natural logarithm' if you've never seen it before, breaking it down into parts like what are the parameters to a log() function and what do they do. You don't really need to know much calculus to do algorithm analysis, algebra manipulation is preferred but we will see the idea of a limit, and e<sup>x</sup> or ln(x) which are both models of exponential ie: 2<sup>n</sup> and logarithmic growth ie: log(n)
</p>
</div>
</div>

<div id="outline-container-Math%20model" class="outline-3">
<h3 id="Math%20model">Math model</h3>
<div class="outline-text-3" id="text-Math%20model">
<p>
Explained <a href="https://papl.cs.brown.edu/2020/predicting-growth.html#%28part._math-anon-functions%29">here</a>: There exists a constant c, for all inputs n to your algorithm f(n), such that f(n) \(\le\) another function scaled by that constant.
</p>

<p>
\[f(n) \le c \cdot g(n)\]
</p>

<p>
In general the n in f(n) and g(n) means inputs approach infinity, if you use f(x) for notation, then somewhere you have to indicate that x -&gt; infinity. This notation is a model of your algorithm that denotes it's bound. We will learn exactly what g(n) is in the CS Theory Toolkit lectures, it's a family of functions you pick from a set of standard functions that best explain the bound. If your algorithm f(n) is linear, then pick a linear g(n). 
</p>
</div>
</div>


<div id="outline-container-CS%20Theory%20Toolkit%20lecture%202" class="outline-3">
<h3 id="CS%20Theory%20Toolkit%20lecture%202">CS Theory Toolkit lecture 2</h3>
<div class="outline-text-3" id="text-CS%20Theory%20Toolkit%20lecture%202">
<p>
Really what we are studying is computational complexity. Algorithm intro courses attempt to introduce this in a very confusing way but what you really should know, to understand algorithms and their analysis, is basic complexity and the art of asymptoptic analysis. So let's do that. The rest will be trivial.     
</p>

<p>
Watch <a href="https://youtu.be/_gKb855_3bk">Big O and friends</a> part of a lecture from CMU's CS Theory Toolkit. You can type all these definitions into desmos to see their visualization like I did <a href="https://www.desmos.com/calculator/xzqea0wfwc">here</a>, then keep zooming out to see how they change when inputs become gigantic. The constant and logarithm become indistinguishable, n log(n) grows very slowly towards 2<sup>x</sup> because it's linear times some logarithmic factor. 'Factor' here means you are multiplying two things, so they will like in highschool break into factors and one will be logarithmic because you multiplied n by log(n). 
</p>

<p>
@1:58 x<sub>0</sub> or 'x naught' means a particular input to f(x) so x<sub>0</sub> for example can be f(5), so all inputs to f(x) equal or greater than 5 this definition holds. @5:40 his anonymous function, that's the Prof K interpretation from CS19, O(n<sup>2</sup>) by itself without the entire f(x) = definition is O([n -&gt; n<sup>2</sup>]). @12:00 10n/n<sup>2</sup> and you jack up inputs to approach infinity you will get a limit of 0, and thus 10n is in the little-o family of functions that are stricly less than the family of functions in n<sup>2</sup> however 10n is still in the family of functions that are Big-O of n<sup>2</sup> (and anything else bigger than linear). @13:29 the anonymous function again, O(1) means O([n -&gt; c]) for all inputs what we get is bounded by a constant. 14:50 log<sup>3</sup> n means (log(n))<sup>3</sup> and since all logarithms are really exponents it's log(n<sup>3</sup>) since (b<sup>1</sup>)<sup>2</sup> is b<sup>2</sup> this is called a <a href="https://en.wikipedia.org/wiki/Polylogarithmic_function">polylogarithmic</a> function 'a polynomial in the the logarithm of n' and denotes it is growing more slowly than any positive polynomial exponent, because it's a log.
</p>

<p>
This is worth expanding on, a polynomial 'in x' means what you learned <a href="https://math.stackexchange.com/a/2185613">highschool</a> The first 10 minutes of <a href="https://youtu.be/JpPNzdlXVYw">this</a> lecture explains why we use them. Here we are talking about a polynomial 'in n' so replace all the x's with the function n or polylogarithmic replace all the x's with log(n). To me at my pleb level of mathematics it means there is a vector space in that function since multiplying/adding a polynomial gives you another one, or it's a object of type Integer <a href="https://youtu.be/H8xBlLWdzBE">ring</a>. 
</p>

<p>
@14:25 let's figure out O-tilde and poly() which you will see in every algorithm paper:
</p>

<ul class="org-ul">
<li>poly(g(x)) or f(x) = g(x)<sup>O(1)</sup>
<ul class="org-ul">
<li>any growth in the form of big-O with a constant exponent</li>
<li>example: O(n)<sup>2</sup> is poly(g(x))</li>
</ul></li>
<li>O-tilde(g(x)) or f(x) = g(x) * log(g(x))<sup>O(1)</sup>
<ul class="org-ul">
<li>fx = g(x) * poly(log(gx))</li>
<li>any growth in the form of g(x) * a logarithmic factor of g(x)</li>
</ul></li>
</ul>

<p>
If c is a constant, notice that log c = n<sup>O(1)</sup> by definition of a logarithm. This means poly(log c) is poly(n) as the definition of poly(g(x)) is g(x)<sup>O(1)</sup>. O(log c) = n<sup>O(1)</sup> and O(log c)<sup>c</sup> is also n<sup>O(1)</sup> and that's what the notation for \(\widetilde{O}\)(g(x)) means. You suppress the logarithmic factors because they're growing much more slowly than whatever the dominant or significant growth is.  
</p>

<p>
So in his lecture, he took \(n^5 \cdot 3^{n}\) and used O-tilde to model it's bound:
</p>
<ul class="org-ul">
<li>n<sup>5</sup> * poly(log(3<sup>n</sup>) or g(x) * poly(log(g(x)))
<ul class="org-ul">
<li>which is n<sup>5</sup> * poly(n * log 3)</li>
<li>which is n<sup>5</sup> * poly(n<sup>O(1)</sup> * constant)</li>
<li>which is 3<sup>n</sup> * poly(n) because all those factors of n<sup>5</sup> they don't matter and are miniscule in comparison to the growth of 3<sup>n</sup></li>
</ul></li>
</ul>

<p>
O-tilde indicates there's some logarithmic growth factors in your bound that you don't care about/couldn't pin down. His check that this isn't 2<sup>n</sup> he uses the first chapter of DPV where they show testing a f(x)/g(x) ratio so 3<sup>n</sup> over 2<sup>n</sup> = 1.5<sup>n</sup> and making sure it's not smaller than poly(n). 
</p>

<p>
Everything past 22:00 or so is in the book <i>Asymptopia</i> by Spencer talking about standard form of functions it just means your family of functions for g(x) should be in 'standard form' as he lays out for example sqrt(n) is standard form but sqrt(n + 1) isn't. He shows how to fix this in part 3. We will read this chapter. 
</p>

<p>
Moving on to <a href="https://youtu.be/Ao6aXSyJ6Gk">part b</a> there's an interesting illustration of harmonic numbers which will surely come up in DPV and how H<sub>n</sub> is in Big-Theta(log n) when you use asymptotics to estimate it. He uses basic integration of 1/x you can see <a href="./calculus.html">here</a> which is log(x) but the point here is manipulating results so you can get that form of something tending towards 1.     
</p>

<p>
Moving on to <a href="https://youtu.be/flge97Jp6uo">part 3</a> the magic of asymptotics: e<sup>x</sup> is roughly 1 + x for small x. The rest of lecture is showing how you take a complicated expression and simplify it with asymptotics exactly what we will see in every algorithms text or paper.
</p>
</div>
</div>

<div id="outline-container-CS%20Theory%20toolkit%20lecture%203" class="outline-3">
<h3 id="CS%20Theory%20toolkit%20lecture%203">CS Theory toolkit lecture 3</h3>
<div class="outline-text-3" id="text-CS%20Theory%20toolkit%20lecture%203">
<p>
When we're done we'll read about this in <i>Asymptopia</i> by Spencer and guess what, you've just finished 80% of the mathematical preliminaries of <i>The Art of Computer Programming</i>.  
</p>

<hr>
<p>
<a href="./index.html">Home</a>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
