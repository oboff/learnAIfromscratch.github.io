<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-03-04 Thu 22:52 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Computer Science from Scratch</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  body {
  max-width: 40rem;
  padding: 1rem;
  margin: auto;
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style> body {background-color: #fafad2} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Computer Science from Scratch</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Intro">Intro</a></li>
<li><a href="#Start%20here">Start here</a>
<ul>
<li><a href="#Materials%20needed%20to%20complete%20this">Materials needed to complete this</a></li>
</ul>
</li>
<li><a href="#Lecture%201%20Pyret%20Demo">Lecture 1 Pyret Demo</a>
<ul>
<li><a href="#Design%20Recipe%20paraphrased">Design Recipe paraphrased</a></li>
<li><a href="#PAPL%20chapter%203%20%2FGetting%20Started%2F">PAPL chapter 3 <i>Getting Started</i></a></li>
<li><a href="#PAPL%20chapter%204%20%2FNaming%20Values%2F">PAPL chapter 4 <i>Naming Values</i></a></li>
<li><a href="#PAPL%20chapter%205%20%2FFunctions%2F">PAPL chapter 5 <i>Functions</i></a></li>
<li><a href="#PAPL%20chapter%206%20%2FConditionals%2F">PAPL chapter 6 <i>Conditionals</i></a></li>
</ul>
</li>
<li><a href="#Lecture%202%20Rainfall%20Problem">Lecture 2 Rainfall Problem</a>
<ul>
<li><a href="#How%20to%20write%20examples">How to write examples</a></li>
<li><a href="#PAPL%20chapter%207%20%26%208%20%2FTabular%20data%2F">PAPL chapter 7 &amp; 8 <i>Tabular data</i></a></li>
<li><a href="#Recitation%3A%20lambdas">Recitation: lambdas</a></li>
<li><a href="#Recitation%3A%20recursion%20%26%20lists">Recitation: recursion &amp; lists</a></li>
<li><a href="#PAPL%20chapter%209%20%26%2010%20%2FLists%2F">PAPL chapter 9 &amp; 10 <i>Lists</i></a></li>
</ul>
</li>
<li><a href="#Lecture%203%20Insertion%20Sort">Lecture 3 Insertion Sort</a></li>
<li><a href="#Assignment%201%3A%20DocDiff">Assignment 1: DocDiff</a>
<ul>
<li><a href="#A%20study%20about%20us%2C%20beginner%20students">A study about us, beginner students</a></li>
<li><a href="#DocDiff">DocDiff</a></li>
<li><a href="#Properties%20testing">Properties testing</a></li>
</ul>
</li>
<li><a href="#Lab%3A%20Higher-Order%20Functions">Lab: Higher-Order Functions</a>
<ul>
<li><a href="#PAPL%20chapter%2011%20%2FStructured%20Data%2F">PAPL chapter 11 <i>Structured Data</i></a></li>
</ul>
</li>
<li><a href="#Assignment%202%3A%20Nile">Assignment 2: Nile</a></li>
<li><a href="#Lecture%204%20Big-O">Lecture 4 Big-O</a>
<ul>
<li><a href="#PAPL%20Chapter%2017%20%2FPredicting%20Growth%2F">PAPL Chapter 17 <i>Predicting Growth</i></a></li>
</ul>
</li>
<li><a href="#Lecture%205%20Insertion%20Sort%20Reccurrence">Lecture 5 Insertion Sort Reccurrence</a>
<ul>
<li><a href="#More%20Recurrences">More Recurrences</a></li>
<li><a href="#Return%20to%2017.10%20Recurrences">Return to 17.10 Recurrences</a></li>
<li><a href="#Lab%3A%20Big-O%201">Lab: Big-O 1</a></li>
</ul>
</li>
<li><a href="#Lecture%206%20Quicksort">Lecture 6 Quicksort</a></li>
<li><a href="#Assignment%203%3A%20Sortacle">Assignment 3: Sortacle</a>
<ul>
<li><a href="#Check%20your%20work%20against%20the%20official%20solution">Check your work against the official solution</a></li>
<li><a href="#Logic%20for%20Systems">Logic for Systems</a></li>
</ul>
</li>
<li><a href="#Assignment%204%3A%20Data%20Scripting">Assignment 4: Data Scripting</a></li>
<li><a href="#Lecture%207%20Trees">Lecture 7 Trees</a>
<ul>
<li><a href="#PAPL%20Chapter%2013%20%2FRecursive%20datatypes%2F">PAPL Chapter 13 <i>Recursive datatypes</i></a></li>
</ul>
</li>
<li><a href="#Lecture%208%20Sets">Lecture 8 Sets</a>
<ul>
<li><a href="#PAPL%20Chapter%2012%20%26%2018.1%20%2FSets%2F">PAPL Chapter 12 &amp; 18.1 <i>Sets</i></a></li>
<li><a href="#PAPL%20Chapter%2015%20%2FOracles%2F">PAPL Chapter 15 <i>Oracles</i></a></li>
</ul>
</li>
<li><a href="#Assignment%205%3A%20Oracle">Assignment 5: Oracle</a>
<ul>
<li><a href="#Check%20your%20solution">Check your solution</a></li>
</ul>
</li>
<li><a href="#Lecture%209%20Logarithmic%20Growth">Lecture 9 Logarithmic Growth</a></li>
<li><a href="#Lecture%2010%20Balanced%20Binary%20Search%20Trees">Lecture 10 Balanced Binary Search Trees</a>
<ul>
<li><a href="#PAPL%20Chapter%2018.2%20%2FTrees%2F">PAPL Chapter 18.2 <i>Trees</i></a></li>
<li><a href="#Lab%3A%20Tree%20Traversal">Lab: Tree Traversal</a></li>
</ul>
</li>
<li><a href="#Assignment%206%3A%20Filesystem">Assignment 6: Filesystem</a></li>
<li><a href="#Assignment%207%3A%20Updater">Assignment 7: Updater</a></li>
<li><a href="#Lecture%2011%20Streams">Lecture 11 Streams</a>
<ul>
<li><a href="#PAPL%20Chapter%2016%20%2FFunctions%20as%20Data%2F">PAPL Chapter 16 <i>Functions as Data</i></a></li>
<li><a href="#Lab%3A%20Streams">Lab: Streams</a></li>
</ul>
</li>
<li><a href="#Lecture%2012%20Model%20View%20Controllers">Lecture 12 Model View Controllers</a></li>
<li><a href="#Lecture%2013%20Differential%20Systems">Lecture 13 Differential Systems</a></li>
<li><a href="#Lecture%2014%20Aliasing">Lecture 14 Aliasing</a></li>
<li><a href="#Lecture%2015%20Monads%2C%20Sequential%20Computation">Lecture 15 Monads, Sequential Computation</a></li>
<li><a href="#CS19%20Lectures%20on%20Graphs">CS19 Lectures on Graphs</a></li>
<li><a href="#CS19%20Lectures%20on%20mutation">CS19 Lectures on mutation</a>
<ul>
<li><a href="#Lecture%2024%20Memory%20refs">Lecture 24 Memory refs</a></li>
<li><a href="#Lecture%2025%20Closures">Lecture 25 Closures</a></li>
<li><a href="#PAPL%20Chapter%2022">PAPL Chapter 22</a></li>
<li><a href="#The%20rest%20of%20the%20cs19%20lectures">The rest of the cs19 lectures</a></li>
</ul>
</li>
<li><a href="#Algorithms">Algorithms</a></li>
</ul>
</div>
</nav>

<div id="outline-container-Intro" class="outline-2">
<h2 id="Intro">Intro</h2>
<div class="outline-text-2" id="text-Intro">
<p>
This is part IA of the <a href="https://learnaifromscratch.github.io">AI Tripos</a> to learn computer science from the beginning. If you only have a phone you can complete this. What I do is just provide TA notes, which are optional for you to read, so if things come up in lectures or reading I identify as 'this would confuse me when I a beginner' then I will add a comment about it which may help you complete this material.
</p>

<p>
This is a draft I'm rewriting from scratch
</p>
</div>
</div>

<div id="outline-container-Start%20here" class="outline-2">
<h2 id="Start%20here">Start here</h2>
<div class="outline-text-2" id="text-Start%20here">
<p>
We begin with Brown University's <a href="https://cs.brown.edu/courses/cs019/">CSCI 0190</a> or cs19 <i>Accelerated Introduction to Computer Science</i>. This course was chosen because all the complexity of learning to program is removed, it contains advanced concepts not taught in other intro courses and the teaching style of the instructor is very different than any other lecture you've seen. 
</p>
</div>

<div id="outline-container-Materials%20needed%20to%20complete%20this" class="outline-3">
<h3 id="Materials%20needed%20to%20complete%20this">Materials needed to complete this</h3>
<div class="outline-text-3" id="text-Materials%20needed%20to%20complete%20this">
<p>
As stated in the intro it's possible to complete this course with just a phone or a tablet
</p>
<ul class="org-ul">
<li>the <a href="https://papl.cs.brown.edu/2020/">book</a> <i>Programming and Programming Languages</i> (use the most latest version, which is 2020)</li>
<li>lectures are on <a href="https://www.youtube.com/playlist?list=PLl0tHXI7SBjncgRrhL4DPEwDgUjUtk2_C">YouTube</a>
<ul class="org-ul">
<li>the lectures cover extra material not in the book</li>
</ul></li>
<li>the Pyret online <a href="https://www.pyret.org/set-sail/">interpreter</a> (CPO)</li>
<li>the 2018 copy of the <a href="https://cs.brown.edu/courses/cs019/2018/assignments.html">assignments</a> since we are watching the 2018 lectures</li>
<li>the labs at the bottom of this <a href="https://cs.brown.edu/courses/cs019/2016/assignments.html">page</a> (Big-O, Higher-Order Functions, Streams etc).</li>
</ul>
</div>

<div id="outline-container-Torrent%20archive" class="outline-4">
<h4 id="Torrent%20archive">Torrent archive</h4>
<div class="outline-text-4" id="text-Torrent%20archive">
<p>
I made a torrent w/the lectures and labs:
</p>
<pre class="example" id="org003b211">
CS019 2018 Lectures, labs
magnet:?xt=urn:btih:5db2ed40c8952ea69a06c4ab940d168bc2798a49&amp;dn=cs019
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-Lecture%201%20Pyret%20Demo" class="outline-2">
<h2 id="Lecture%201%20Pyret%20Demo">Lecture 1 Pyret Demo</h2>
<div class="outline-text-2" id="text-Lecture%201%20Pyret%20Demo">
<p>
We're starting with the cs19 lecture titled <a href="https://www.youtube.com/playlist?list=PLl0tHXI7SBjncgRrhL4DPEwDgUjUtk2_C">Wed 9-5-18</a>. Go to code.pyret.org (referred to as CPO) and click <i>open editor</i> as you follow along the lecture. The book we are reading will cover everything he's doing like what a list is, what a function is, this is just a demonstration of the online interpreter. You can run Pyret <a href="https://www.pyret.org/set-sail/">offline</a> too.
</p>


<p>
With CPO open (code.pyret.org) cut + paste the following on the left hand side and click Run:
</p>

<pre class="example" id="orgef665fc">
# this is a comment it doesn't get run because it begins with #
empty
"this is what the empty list looks like"

link(1, empty) 
"link 1 to the empty list"
#link syntax: link(element, a-list)
#first = 1, rest = empty. 

link(2, link(1, empty))
"link(2, link(1, empty))"
#first = 2, rest = [list: 1]
#read this as link(2, (list))

my-list = [list: 1/3, -100, "b", true]
my-list
# List with 4 different types:
# 1/3 = 'Roughnum' or floating point
# -100 = Number 
# "b" = String
# true = Boolean
# you usually don't mix types in a single list

my-list.first #first element
"my-list.first (click on 0.3333.. it will show 1/3)"

my-list.rest #the list without the first element
"my-list.rest (click on the list it expands each item)"

my-list.rest.first 
"the first of the rest"

# function syntax: fun name(input1, input2): end
# 'input1' is a placeholder that binds the input to a name
fun add-one(n): 
  n + 1  
end

# use 'where' to add tests
fun add-one-again(g):
  g + 1
  where:
  add-one-again(0) is 1
  add-one-again(-1) is 0 
  add-one-again(1/2) is 1 + 1/2
end

# you can add description to check blocks
check "add-one checkblock":
  add-one(10) is add-one(9) + add-one-again(0)
end

fun add-two(a, b): # two inputs
  a + b
where:
  add-two(1, 2) is 3
  add-two(1, 2) is add-one(2)
end
</pre>

<p>
How does len (length of a list) function work in lecture calling itself?  Clear out CPO and paste the following:
</p>

<pre class="example" id="org4ebcdf0">
# link(f, r) deconstructs the list
# [list: 1, 2] is link(1, [list: 2]) f = 1, r = [list: 2]

# x is type List&lt;Number&gt;, -&gt; means return type Number
fun len3(x :: List&lt;Number&gt;) -&gt; Number:
  cases (List) x:
    | empty =&gt; 0
    | link(f, r) =&gt; 1 + len1(r)
  end
end

fun len2(x :: List&lt;Number&gt;) -&gt; Number:
  cases (List) x:
    | empty =&gt; 0
    | link(f, r) =&gt; 1 + len3(r)
  end
end

fun len1(x :: List&lt;Number&gt;) -&gt; Number:
  cases (List) x:
    | empty =&gt; 0
    | link(f, r) =&gt; 1 + len2(r) 
  end
end

check:
  len1(empty) is 0
  len1([list: 1, 2]) is len2([list: 1]) + len3([list: 2]) + len1(empty)
end

"Hand step len1"
len1([list: 1, 2, 3])
1 + len2([list: 2, 3])
1 + (1 + len3([list: 3]))
1 + 1 + (1 + len1(empty))
# 1 + 1 + 1 + 0 

fun size-of-list(g):
  cases (List) g:
    | empty =&gt; 0
    | link(first, rest) =&gt; 1 + size-of-list(rest)
  end
where:
  size-of-list(empty) is 0
end

"Hand step size-of-list"
size-of-list([list: 1, 2])
1 + size-of-list([list: 2])
1 + 1 + size-of-list(empty)
# 1 + 1 + 0 
</pre>

<p>
Pretend self-reference/recursive function calls are calling an exact copy of your function, with one less list element each time, and you are waiting for all the calls to stop on the empty case and return values, that is the good enough beginning insight to recursion until we learn more in this course.  
</p>

<p>
Watching the lecture, Examplar is talked about which we don't have access to, if you look up the professor's Brown university page he has a <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wk-stud-write-test-no-coercion/">paper</a> about on Examplar detailing how many tests the students typically write which is 30+. The whole paper is worth a read since you are doing the very course the paper is about. A good quote from the paper introduction <b>"students lack the metacognitive awareness to self-regulate their progress"</b> meaning we begin the implementation before thinking about the problem, get frustrated when our solutions don't work or are filled with bugs, and give up too early. We can mimic Examplar by just writing a bunch of test cases ourselves. Note that this is not 'test driven development' or any other scheme you've heard of, it is example writing to figure out the problem domain. 
</p>

<p>
So how can we figure out the student given test cases for the median program? By looking up what a <a href="https://en.wikipedia.org/wiki/Median">median</a> is and the procedure to find it. Reading that article we see that the median is a value that seperates a finite list of numbers, that can be found by arranging them from the smallest to the greatest. If there is an odd number of entries, the middle number that splits the list into two even parts is picked. Otherwise it is defined to be the mean of the two middle values which means add them both and divide by 2, the idea being getting as close as possible to evenly splitting the data. That's why the test for [list: 1, 3, 2] is 2 because your program would reorder the list to be [list: 1, 2, 3] and choose 2 as the median.
</p>

<p>
The Fermi problems he talks about are released on Piazza which requires campus logins, <a href="https://piazza.com/class">https://piazza.com/class</a> is a kind of wiki/msg forum for courses that encourages anonymous postings so students don't feel embarassed to ask questions. A lot of universities now solely distribute their course materials through it meaning the public doesn't have access anymore. You can find these yourself online anyway by searching for Fermi problems.
</p>
</div>

<div id="outline-container-Design%20Recipe%20paraphrased" class="outline-3">
<h3 id="Design%20Recipe%20paraphrased">Design Recipe paraphrased</h3>
<div class="outline-text-3" id="text-Design%20Recipe%20paraphrased">
<p>
At the end of lecture 1, prof K mentions the design recipe from his other book <a href="https://htdp.org/2018-01-06/Book/HtDP">HtDP</a>. If you read the <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/rkf-student-ta-hours/">paper</a> <i>What Help Do Students Seek in TA Office Hours</i> it is again about the same course you are presently taking and very relevant to his comments in lecture. The following is the design recipe, it won't make sense until we start using it for the assignments:
</p>

<ul class="org-ul">
<li>Data Definitions
<ul class="org-ul">
<li>Understand the information provided by the problem and form data definitions to represent it as data.</li>
</ul></li>
<li>Signature, Purpose Statement, Header
<ul class="org-ul">
<li>State a name, purpose, and type—in terms of what it consumes and produces—for the function (or program) being defined.</li>
</ul></li>
<li>Functional Examples
<ul class="org-ul">
<li>Work through examples that illustrate the function’s purpose.</li>
</ul></li>
<li>Function Template
<ul class="org-ul">
<li>Translate the data definitions into an outline of the function.</li>
</ul></li>
<li>Function Definition
<ul class="org-ul">
<li>Fill in the gaps in the function template, exploiting the purpose statement and the examples.</li>
</ul></li>
<li>Testing
<ul class="org-ul">
<li>Make sure the function passes the tests, and construct additional tests as needed based on the implementation details.</li>
</ul></li>
</ul>

<p>
Going through these design stages, as you will read in many more papers as we finish this course, is modelled by Polya's famous book <i>How to Solve It</i> which every single professor and teacher since it's publication has been trying to teach students: a systematic way of thinking about problems.
</p>

<p>
tl;dr you are doing Polya's <i>How to Solve It</i> adapted for <a href="https://dl.acm.org/doi/pdf/10.1145/2858036.2858252">intro programming</a>.
</p>
</div>
</div>


<div id="outline-container-PAPL%20chapter%203%20%2FGetting%20Started%2F" class="outline-3">
<h3 id="PAPL%20chapter%203%20%2FGetting%20Started%2F">PAPL chapter 3 <i>Getting Started</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%203%20%2FGetting%20Started%2F">
<p>
Let's work through the <a href="https://papl.cs.brown.edu/2020/">book</a> <i>Programming and Programming Languages</i>, the chapters aren't very long. I'm using whatever the latest version is (as of this writing, 2020). These aren't long chapters, and we have to catch up to the class as they were all assigned reading in the summer break before the semester which consisted of numerous chapters out of his other book <i>How to Design Programs</i>. 
</p>

<p>
To quote prof K:
</p>
<blockquote>
<p>
If you are new to programming: people learn programming by actually writing programs and running them. As you read, type in the code in the document, see how it works, change it a little and see what happens. Actually trying the code in the assigned reading will be essential for you to get comfortable with the material.
</p>
</blockquote>

<p>
Chapter 3 <i>Getting Started</i> read while you have CPO open (<a href="https://code.pyret.org">https://code.pyret.org</a>). The examples with many "&gt;" in front of them indicate to enter this into the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>, on the right hand side of the pyret code editor like he did in the lecture pressing enter to eval. You can increase the font size if you click the lambda skull logo on the top left side.
</p>
</div>
</div>


<div id="outline-container-PAPL%20chapter%204%20%2FNaming%20Values%2F" class="outline-3">
<h3 id="PAPL%20chapter%204%20%2FNaming%20Values%2F">PAPL chapter 4 <i>Naming Values</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%204%20%2FNaming%20Values%2F">
<p>
This <a href="https://papl.cs.brown.edu/2020/Naming_Values.html">chapter</a> tells you exactly what happens in CPO when you click the run button or Ctrl-Enter. If you make a mistake like accidentally deleting all your code Ctrl-z will undo on most browsers I tested it on.
</p>

<p>
"In programming, we distinguish expressions, which yield values, from statements which don’t yield values but instead give some other kind of instruction to the language". You will see the words expression, definition (statement) everywhere in programming literature and now you know what it means.
</p>

<p>
The chapter exercise of defining width twice, shadowing is in the <a href="https://www.pyret.org/docs/latest/Bindings.html#%28part._.Shadowing%29">documentation</a> and we will learn more about it when we do the last half of PAPL. What this means is the program directory is immutable you can't change a variable's defined value while in that variable's scope, meaning the 'range of significance' unless you use special built-in keywords to do so which we will see later for manipulating memory.
</p>

<p>
The <i>Do Now</i> at end of 4.3, why did two-rects disappear from the program directory? Because of how <i>Run</i> works, it clears out the existing directory and loads a new one from the definitions in the definition window, so if you have temporary defined variables in the interactive right hand window they will be lost once you use <i>Run</i>.
</p>

<p>
4.4 reminder all these built-ins can be <a href="https://www.pyret.org/docs/latest/image.html#%28part._.Overlaying_.Images%29">looked up</a> in the documentation if you're unsure what is going on. Copy all the code and change the images around to see what happens.
</p>
</div>
</div>


<div id="outline-container-PAPL%20chapter%205%20%2FFunctions%2F" class="outline-3">
<h3 id="PAPL%20chapter%205%20%2FFunctions%2F">PAPL chapter 5 <i>Functions</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%205%20%2FFunctions%2F">
<ul class="org-ul">
<li>There is an optional recorded recitation for this chapter <a href="https://youtu.be/kR1DvZ17mkc">here</a></li>
</ul>

<p>
This chapter tells you exactly how functions are defined and run by Pyret, and what annotated parameters are which will come up in every future lecture.
</p>

<p>
Something I used to do when beginning was delete a parens and add it again to see the scope, as these expressions can grow in massive size and can get confusing what is actually happening. CPO instead will highlight where it begins/ends if you move arrow keys around the closing brackets. For example that large frame/above flag in 5.2.1:
</p>

<pre class="example" id="org89b5fe6">
frame(
  above(rectangle(120, 30, "solid", top),
    above(rectangle(120, 30, "solid", middle),
      rectangle(120, 30, "solid", bot)))) &lt;-- use arrow keys here to navigate closing scope

this is: frame(img)
  img = above(thing1, thing2)
  thing2 = above(rec1, rec2) 
</pre>

<p>
There's a <i>Do Now!</i> asking should we combine test cases for pen-cost(0, "") is 0 which from how the code is written, it's (0 * (value)) once you evaluate everything in the brackets, so I'm going to claim it's fine to combine test cases since zero times anything is zero. This function pen-cost returns a number, so you can add or multiply it with itself:
</p>

<pre class="example" id="orga27921f">
# addition test
pen-cost(3, "wow") + pen-cost(10, "smile")

# division test
pen-cost(3, "wow") / pen-cost(10, "smile")

# function as a parameter test
pen-cost(pen-cost(3, "wow"), "test")

# multiple functions as a parameter test
# this is: pen-cost((value * value), "smile")
pen-cost((pen-cost(3, "wow") * pen-cost(1, "test")), "smile")

</pre>

<p>
The last few examples above use a call to pen-cost as it's own input which of course gives nonsensical values returned like cost is 0.150381. The 'num-pens' parameter should only allow natural numbers, like 1, 2, 3 etc and raise error for anything else since you can't buy 1.5 or negative pens. The easiest way to do this would be to make a custom type for num-pens to be a natural number which we will learn as this course goes on.
</p>
</div>
</div>

<div id="outline-container-PAPL%20chapter%206%20%2FConditionals%2F" class="outline-3">
<h3 id="PAPL%20chapter%206%20%2FConditionals%2F">PAPL chapter 6 <i>Conditionals</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%206%20%2FConditionals%2F">
<p>
Conditional expressions and exactly how Pyret evaluates if-branches is defined here, all you do in this chapter is manually follow code through if-branches, or looking at the <a href="https://www.pyret.org/docs/latest/booleans.html">documentation</a>. 
</p>
</div>
</div>
</div>

<div id="outline-container-Lecture%202%20Rainfall%20Problem" class="outline-2">
<h2 id="Lecture%202%20Rainfall%20Problem">Lecture 2 Rainfall Problem</h2>
<div class="outline-text-2" id="text-Lecture%202%20Rainfall%20Problem">
<p>
Watch the Mon9/10/18 second lecture. The very first task, just imagine it in your head you don't have to actually write a program. Interesting lecture about the rainfall problem and the benefits of writing a lot of examples in order to understand badly defined problems. Data science/machine learning is brought up, as examples of dirty data. Higher-order functions are talked about, like filter and map which are in the Pyret documentation and we will learn in depth later.
</p>

<p>
We skipped the placement all these students did, if you're interested it's <a href="http://cs19.cs.brown.edu/2017/placement-1.html">here</a> and consists of reading some chapters out of <a href="https://htdp.org/2020-8-1/Book/index.html">HtDP</a>, then doing some homework in Racket lang. Instead we are doing the exact same content in PAPL, because we have the luxury of time whereas they have to complete assignments every few days starting with the first lecture so are forced into reading HtDP over the summer. We will catch up with them after next lecture.
</p>

<p>
What to get out of this lecture "Data is noisy, produced by flaky hardware and buggy programs and you will have no choice but to clean the data".
</p>

<p>
There's a video from the 'Advanced R' book author at the end, which is <a href="https://youtu.be/GyNqlOjhPCQ">here</a> and the gist of that talk is reducing things based on what is similar so you can generalize. We haven't done map/filter etc., but will quickly catch up by lecture 4. 
</p>
</div>

<div id="outline-container-How%20to%20write%20examples" class="outline-3">
<h3 id="How%20to%20write%20examples">How to write examples</h3>
<div class="outline-text-3" id="text-How%20to%20write%20examples">
<p>
This <a href="https://youtu.be/cTQI4iN1VDg">recitation video</a> talks about good examples and the program directory meaning what is in scope. The end introduces table shaped data ie: databases. 
</p>
</div>
</div>

<div id="outline-container-PAPL%20chapter%207%20%26%208%20%2FTabular%20data%2F" class="outline-3">
<h3 id="PAPL%20chapter%207%20%26%208%20%2FTabular%20data%2F">PAPL chapter 7 &amp; 8 <i>Tabular data</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%207%20%26%208%20%2FTabular%20data%2F">
<ul class="org-ul">
<li>There is a recorded recitation for these chapters <a href="https://youtu.be/3my9aovhOO8">here</a></li>
</ul>

<p>
This is actually an SQL/database introduction, in the previous versions of PAPL he noted why they composed these table row operations to be independent of each other so combining them in complex expressions is possible just like <a href="https://youtu.be/6VCHuLqfmV8">SQL</a> or Excel spreadsheets that every trader <a href="https://news.ycombinator.com/item?id=15819016">still uses</a>. This chapter has a good writeup about having a clear error model to think through.
</p>

<p>
There's an exercise using only booleans, how would you write the function is-email(e :: string) &#x2013;&gt; Boolean? Look through the <a href="https://www.pyret.org/docs/latest/strings.html#%28part._strings_string-contains%29">docs</a>. 
</p>

<pre class="example" id="org305b936">
fun is-email(e :: String) -&gt; Boolean:
  doc: "Incorrect program to verify is-email"

  string-contains(e, "@") and (string-contains(e, ".com") or string-contains(e, ".edu") or string-contains(e, ".org"))
where:
  is-email("a@wrongdomain.no") is false
  is-email("b@test.com") is true
  is-email("ckljfk.edu") is false
  is-email("d@d.edu") is true

  # these two last test cases fail of course
  is-email("@.edu") is false
  is-email("a@@.edu") is false
end
</pre>

<p>
The advice in this chapter is to force inputs through a structure like a form to ensure they are complete instead of allowing any arbitrary user supplied input.  
</p>
</div>
</div>

<div id="outline-container-Recitation%3A%20lambdas" class="outline-3">
<h3 id="Recitation%3A%20lambdas">Recitation: lambdas</h3>
<div class="outline-text-3" id="text-Recitation%3A%20lambdas">
<p>
This <a href="https://youtu.be/vxXFDS95nB4">recitation</a> explains anonymous functions using table row operations as examples, at this stage they're just functions without a name so you can write more readable one-liners, later we will learn how they give us things like closures and much later when we do the end of the book/language theory, we will see it's just lambdas all the way down.
</p>

<p>
Play around in CPO:
</p>

<pre class="example" id="org3e7ff0d">
test = lam(x): x + 1 end
&gt;&gt;&gt;test(2)
3
&gt;&gt;&gt;test(2 + test(2))
6
</pre>
</div>
</div>


<div id="outline-container-Recitation%3A%20recursion%20%26%20lists" class="outline-3">
<h3 id="Recitation%3A%20recursion%20%26%20lists">Recitation: recursion &amp; lists</h3>
<div class="outline-text-3" id="text-Recitation%3A%20recursion%20%26%20lists">
<p>
A <a href="https://youtu.be/XEOLa6J2_F0">tutorial</a> on lists, case syntax and recursion helpful when reading chapter 9 and 10. 'Recursion means you do not need to know how to solve the entire problem in one go, you only need to know how to do one step'.
</p>
</div>
</div>

<div id="outline-container-PAPL%20chapter%209%20%26%2010%20%2FLists%2F" class="outline-3">
<h3 id="PAPL%20chapter%209%20%26%2010%20%2FLists%2F">PAPL chapter 9 &amp; 10 <i>Lists</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%209%20%26%2010%20%2FLists%2F">
<p>
This chapter is not about learning lists, it's about "how readily the structure of the data suggest a structure for the program". We will later see data in the structure of sets, queues, trees, streams, graphs that drive the code too.
</p>

<p>
<b>10.42 my-pos-nums</b>
</p>

<p>
The exercise is to hand step the function thinking about the examples, then copy the code and tests to CPO:
</p>
<pre class="example" id="orgaf17422">
fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
where:
  # exercise: lists ending with positive, or with 0
  my-pos-nums([list: 1, -2, 3, 4])  is [list: 1, 3, 4]
  my-pos-nums([list:    -2, 0, -4]) is empty
end
</pre>

<p>
Hand step my-pos-nums program: 
</p>

<details id="orge20b088">
<pre class="example" id="org52d5b7c">
my-pos-nums([list: 1, -2, 3, 4])

f = 1, r = [list: -2, 3, 4]
  is 1 &gt; 0? 
   link(1, my-pos-nums([list: -2, 3, 4]))
   
f = -2, r = [list: 3, 4]
  is -2 &gt; 0?
   my-pos-nums([list: 3, 4])
   
f = 3, r = [list: 4]
  is 3 &gt; 0?
   link(1, link(3, my-pos-nums([list: 4]))
   
f = 4, r = empty
  is 4 &gt; 0?     
   link(1, link(3, link(4, my-pos-num(empty))))

f = nothing, r = empty
 is list empty?
  return empty as per cases statement
  
No more delayed computations, start with inner bracket and produce values:
link(1, link(3, link(4, empty)))
 link(1, link(3, [list: 4]))
  link(1, [list: 3, 4])
   [list: 1, 3, 4]
</pre>

<p>
Link syntax is link(element, list) and all those link element operations are pending while waiting to resolve a list it can link the element to. They are waiting because everytime my-pos-nums is called, it calls another function (itself) with 1 less input.
</p>
</details>

<p>
<b>10.5.1 my-max</b>
</p>

<p>
The exercise "Suppose num-max were not already built in, can you define it?" Try some examples, the function writes itself:
</p>

<pre class="example" id="org647f820">
  my-num-max(1,  2) is 2
  my-num-max(1, -1) is 1
  my-num-max(2,  2) is 2

if a &gt; b:
   a
else:
   b 
</pre>

<p>
<b>10.7 Accumulators</b>
</p>

<p>
<i>"Observe that we do not change my-running-sum itself to take extra arguments. There are multiple reasons for this"</i>. One reason is you want simple documentation, user intuitive and bug-free access to my-alternating() just like a typical command shell utility such as change directory (cd) you wouldn't have users init your accumulators with cd(empty, 0, dir-name) you would instead want a simple interface where all internal operations are encapsulated that only takes a single input.
</p>

<p>
Try the exercise for my-max with an accumulator:
</p>

<pre class="example" id="org6370548">
fun my-max(l :: List&lt;Number&gt;) -&gt; Number:
  doc: "my-max with an accumulator exercise"

  fun helper(acc :: Number, e :: List&lt;Number&gt;) -&gt; Number:
    cases (List) e:
      | empty =&gt; acc
      | link(f, r) =&gt; 
        if f &gt; acc: 
          helper(f, r)
        else:
          helper(acc, r)
        end
    end
  end

  helper(0, l)
where:
  my-max([list: 2, 1, 4, 3, 2])  is 4
  my-max([list: 1, 4, -3, 4]) is 4
  my-max([list: 2]) is 2
  my-max([list: 0, 0.1, -0.11]) is 0.1
  my-max([list: 1/3, 1/4]) is 1/3
end

This uses a 'trampoline', as evaluation drops down to helper(0, l) which 'jumps' back into the body
</pre>

<p>
<b>10.7.2 my-alternating</b>
</p>

<p>
I wrote this with a helper function, using 'polymorphic type' annotations as defined end of this chapter. Try clicking on the Pyret Run button and change it to <i>Type-Check and Run</i> for static type checking. These type annotations 'T' and 'A' mean the function can accept any type such as booleans, strings, numbers, where the program will infer the type based on what the inputs are. If you're wondering T, A are just variables you can change to anything so long as they aren't existing types already defined:
</p>

<p>
Example, my-alt could also be:
</p>
<pre class="example" id="org9017401">
fun my-alt&lt;Anything&gt;(e :: List&lt;Anything&gt;, keep :: Boolean) -&gt; List&lt;Anything&gt;:
</pre>

<pre class="example" id="orga7e1ca6">
fun my-alternating&lt;T&gt;(l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
  doc: "my-alternating with type annotations"

  fun my-alt&lt;A&gt;(e :: List&lt;A&gt;, keep :: Boolean) -&gt; List&lt;A&gt;:
    cases (List) e:
      | empty =&gt; empty
      | link(f, r) =&gt;
        if keep:
          link(f, my-alt(r, false))
        else:
          my-alt(r, true)
        end
    end
  end
  my-alt(l, true)
where:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:             5, 6]) is [list:       5]
  my-alternating([list:                 ]) is [list:        ]
  my-alternating([list: 1, 2, 3, 4, 5])    is [list: 1, 3, 5]
  my-alternating([list:       3, 4, 5])    is [list:    3, 5]
  my-alternating([list:             5])    is [list:       5]
  my-alternating([list: "a", "b", "c"])    is [list: "a", "c"]
  my-alternating([list: true, false, true]) is [list: true, true]
end
</pre>

<p>
<b>10.8.4 uniq-rec3</b>
</p>

<p>
ur = uniq-rec(r) meaning it called uniq-rec with the rest of the list and now is only checking that returned distinct rest instead of having the first element in uniq-rec3 linearly go through the entire rest. If the rest of the list is a billion entries, many of them dupes, then you saved yourself 1 iteration of a billion checks by slicing off the first element and comparing it to an already distinct rest.  
</p>

<p>
<b>Polymorphic Types</b>
</p>

<p>
In 10.9 my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; T: means the list can be any type &lt;T&gt;, but it's first element enforces what type the rest will be (string, number, boolean, custom type). Why does it return type T? Maybe there is a notion of max string or max custom type instead of always returning a number. This will come up lecture repeatedly and eventually when we learn <a href="https://papl.cs.brown.edu/2020/para-poly.html">parameterization over types</a>. 
</p>
</div>
</div>
</div>


<div id="outline-container-Lecture%203%20Insertion%20Sort" class="outline-2">
<h2 id="Lecture%203%20Insertion%20Sort">Lecture 3 Insertion Sort</h2>
<div class="outline-text-2" id="text-Lecture%203%20Insertion%20Sort">
<p>
We're watching Wed9/12/18 <a href="https://youtu.be/NVwqTul3f3A">lecture</a> on sorting. We have almost caught up to the class now. 
</p>

<p>
He walks through exactly what a template is and how to extract data to make a template, and spends the rest of the class writing insertion sort using only what we know so far. You have to hand step through it a little to understand what insertion sort is doing. Function sort is calling insert with insert(f, sort(r)) it isn't calling insert(f, r).
</p>

<p>
This is the code on the board which you should have typed into CPO yourself:
</p>

<pre class="example" id="org945c198">

fun insert(n :: Number, l :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
  cases (List) l:
    | empty =&gt; [list: n]
    | link(f, r) =&gt; if n &lt;= f:
        link(n, l)
      else:
        link(f, insert(n, r))
      end
  end
where:
  # student given examples:
  insert(2,  [list: 3,4,5])   is [list: 2,3,4,5]
  insert(1,  [list: 0,1,1,2]) is [list: 0,1,1,1,2]
  insert(-1, [list: -2,0,3])  is [list: -2,-1,0,3]
  insert(3,  [list: ])        is [list: 3]
  insert(4,  [list: 1,2,3])   is [list: 1,2,3,4]
end

fun sort(l :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt; insert(f, sort(r))
  end
where:
  sort([list: 3,2,1])        is [list: 1,2,3]
  sort([list: 1,2,3])        is [list: 1,2,3] 
  sort([list: 4,1,-1])       is [list: -1, 1, 4]
  sort([list: 0.1, 0, 0.11]) is [list: 0, 0.1, 0.11]
end
</pre>

<p>
Let's step the evaluation by hand with [list: 0, 1, 3, 2] being input to sort(). Reaching the cases we have f = 0, r = [list: 1, 3, 2]. We call insert on f, but computation is delayed as we have to wait for the calls to sort(r) to complete since everytime we enter the cases with a non empty list to sort, it calls itself with the rest of the list. We end up with this delayed computation:
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3,(insert(2, empty)))))))</li>
</ul>

<p>
Evaluation starts at the most nested bracket, which is insert(2, empty): 
</p>

<ul class="org-ul">
<li>insert(2, [list: empty])
<ul class="org-ul">
<li>n = 2, l = empty</li>
<li>is list empty? yes so return [list: 2]</li>
</ul></li>
<li>insert(3, [list: 2])
<ul class="org-ul">
<li>n = 3, f = 2, r = [list: empty]</li>
<li>is 3 &lt; 2?</li>
<li>no so link(2, insert(3, [list: empty])</li>
<li>return [list: 2, 3]</li>
</ul></li>
<li>insert(1, [list: 2, 3])
<ul class="org-ul">
<li>n = 1, f = 2, r = [list: 3]</li>
<li>is 1 &lt; 2?</li>
<li>then it must the smallest in the entire list:
<ul class="org-ul">
<li>link(1, [list: 2, 3])</li>
<li>return [list: 1, 2, 3]</li>
</ul></li>
</ul></li>
<li>insert(0, [list: 1, 2, 3])
<ul class="org-ul">
<li>is 0 &lt; 1?</li>
<li>link(0, [list: 1, 2, 3])</li>
<li>return [list: 0, 1, 2, 3]</li>
</ul></li>
<li>no more delayed computations</li>
</ul>

<p>
The returns to sort():
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3, [list: 2])))))</li>
<li>insert(0,(insert(1, [list: 2, 3])))</li>
<li>insert(0, [list: 1, 2, 3])</li>
</ul>

<p>
Everytime a list is returned, the next call to insert can happen because it is complete with insert(n, list).
</p>
</div>
</div>

<div id="outline-container-Assignment%201%3A%20DocDiff" class="outline-2">
<h2 id="Assignment%201%3A%20DocDiff">Assignment 1: DocDiff</h2>
<div class="outline-text-2" id="text-Assignment%201%3A%20DocDiff">
<p>
Let's catch up to the class and try the first <a href="https://cs.brown.edu/courses/cs019/2018/docdiffdocdiff.html">assignment</a>. We can access the assignments before 2019, because the 2020 assignments have a different IDE requiring a brown student login. 
</p>
</div>

<div id="outline-container-A%20study%20about%20us%2C%20beginner%20students" class="outline-3">
<h3 id="A%20study%20about%20us%2C%20beginner%20students">A study about us, beginner students</h3>
<div class="outline-text-3" id="text-A%20study%20about%20us%2C%20beginner%20students">
<p>
Before you begin, if you haven't already from the beginning of this workshop, it will be helpful to read Prof K's <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wk-stud-write-test-no-coercion/">paper</a> about these same cs19 assignments which explains why this course is set up the way it is, what he expects and how he grades these assignments. In the introduction he bluntly informs us that we lack the metacognitive awareness at the beginner stage to self-regulate our progress. Various attempts to fix this have been tried like Polya's <i>How to Solve It</i> problem solving book or his own book <i>How to Design Programs</i> which uses the design recipe template to help beginning students develop this mindset. We as students are supposed to reinterpret the problem ourselves so we actually understand it by writing examples or walking through the design recipe. 
</p>

<p>
Section 2 <i>Pedagogic Context</i> begins to talk about this same course we are doing. He extracts the students tests and runs them against known buggy implementations to see how thorough they are. There's a picture of the new sign-in IDE it's the same CPO except included is a shared g-drive library that tells you your testing progress. This is included to 'coerce' students to write more tests with interactive feedback. He even ran statistics when students click run in the interpreter to see if they were writing examples before hand or just hacking together an implementation immediately. When I started that's what I did, just code and run forgetting about any examples then hit a brick wall and wonder why I couldn't finish the problem.    
</p>

<p>
5.2 tells us exactly how to start these assignments: write 'interesting examples' prior to any implementation. Interesting means an assertion that probes our understanding of the problem. 
</p>
</div>
</div>

<div id="outline-container-DocDiff" class="outline-3">
<h3 id="DocDiff">DocDiff</h3>
<div class="outline-text-3" id="text-DocDiff">
<p>
So now we know what we need to do: write examples that help our understanding and these should be thorough meaning covering the whole problem domain. Let's try DocDiff assignment. 
</p>

<p>
This <a href="https://cs.brown.edu/courses/cs019/2018/docdiffdocdiff.html">assignment writeup</a> seems purposely difficult to get us to write examples to help understand what the assignment wants. The <a href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition">dot product</a> algebraic definition, look at the example for [1,3,-5] x [4,-2,-1]. Each index in the first list is multiplied by it's corresponding index in the second list, then those results are added together. To read the sigma notation, a*b = the sum of \(a_ib_i\) starting at index 1 (first element of the list) up to the length of the list (n). If a = [1<sub>1</sub> ,3<sub>2</sub>, -5<sub>3</sub>] and b = [4<sub>1</sub>, -2<sub>2</sub>, -1<sub>3</sub>]:
</p>

<p>
\(a*b = \sum_{i=1}^3 a_ib_i\) = (\(1_{a1} * 4_{b1})+(3_{a2} * -2_{b2})+(-5_{a3} * -1_{b3})\)
</p>


<p>
Some more requirements are listed, such as ignoring the case (upper/lower) of a word when counting it's number of occurrences. We are given free test cases (document overlap with itself is 1). The exact equation for overlap is given that needs to be translated to a program.    
</p>

<p>
Example vectors:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">test</td>
<td class="org-right">zest</td>
</tr>

<tr>
<td class="org-left">[list: "test"]</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">[list: "zest"]</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
You may want to read the Pyret <a href="https://www.pyret.org/docs/latest/Pyret_Style_Guide.html">style guide</a>. 
</p>

<p>
Let's start with a function that consumes two lists of words, and produces a vector since we were given examples in the assignment writeup:
</p>

<pre class="example" id="orgc6f5e8a">
fun create-vec(a :: List&lt;String&gt;, b :: List&lt;String&gt;) -&gt; List&lt;Number&gt;:
  doc: "Consumes two lists and returns a vector representation of the first input (a)"
  ...
where:
  create-vec([list: "a", "B", "c"], [list: "d", "d", "d", "b"]) is [list: 1, 1, 1, 0] # a, b, c, d
  create-vec([list: "d", "d", "D", "b"], [list: "a", "b", "c"]) is [list: 0, 1, 0, 3] # a, b, c, d
  # sort test
  create-vec([list: "word"], [list: "words"]) is [list: 1, 0] 
  create-vec([list: "w", "ww"], [list: "ww", "a", "w"]) is [list: 0, 1, 1]  
  # same document test
  create-vec([list: "a", "b"], [list: "a", "b"]) is [list: 1, 1]
  # handle empty case
  create-vec(empty, [list: "a"]) raises "Document is empty"
  create-vec([list: "a"], empty) raises "Document is empty"
end
</pre>

<p>
Running the failing tests like this ensures they are at least well formed. Write examples what you think it should produce. In my examples it seems there needs to be some kind of sorting of the vector, using built-in .sort(). From the examples we can see that we take two documents, convert to lower case, produce a sorted unique list of both together, then each document is compared to the total unique list to produce a word frequency count or vector of that document. 
</p>

<p>
I guess we could begin by converting the two lists into the same case:
</p>

<pre class="example" id="org6c146bd">
fun lower-case(l :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
  doc: "Consume a list, return elements all lower case"
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt; link(string-to-lower(f), lower-case(r))
  end
where:
  lower-case([list: "Words"]) is [list: "words"]
  lower-case([list: "B", "b", "B"]) is [list: "b", "b", "b"]
end
</pre>

<p>
Now we need to combine both lists into a total list of all words, filtered for duplicates. The assignment writeup claims we can use any built-in function from the lists <a href="https://www.pyret.org/docs/latest/lists.html">library</a> so <a href="https://www.pyret.org/docs/latest/Import_Statements.html">import</a> the library, use any function there like distinct() or .sort(), or filter function if you know how it works:
</p>

<pre class="example" id="org4659fb4">
import lists as L

fun create-vec(a :: List&lt;String&gt;, b :: List&lt;String&gt;) -&gt; List&lt;Number&gt;:
  doc: "Consumes two lists and returns a vector representation of the first input (a)"
 total-uniq-words = L.distinct(lower-case(a) + lower-case(b)).sort()
 ...
where ...
</pre>

<p>
I imported the lists library as L, so anytime I want to use a function from that library it's library-name.function like L.distinct(). In Pyret every function must produce a value, so this will error we aren't returning anything as the function so far ends with an assignment. 
</p>

<p>
We have our master list of both documents, let's create a vector helper function inside create-vec:
</p>

<pre class="example" id="orgea306b3">
import lists as L

fun create-vec(a :: List&lt;String&gt;, b :: List&lt;String&gt;):
  doc: "Consumes two lists and returns a vector representation of the first input (a)"

  fun lower-case(l :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
    doc: "Consume a list, return elements all lower case"
    cases (List) l:
      | empty =&gt; empty
      | link(f, r) =&gt; link(string-to-lower(f), lower-case(r))
    end
  end

  fun count(c :: String, d :: List&lt;String&gt;) -&gt; Number:
    doc: "Goes through all of list d and counts frequency of string c"
    cases (List) d:
      | empty =&gt; 0
      | link(f, r) =&gt; if f == c: # bug here, see testing properties
          1 + count(c, r)
        else:
          count(c, r)
        end
    end
  end

  fun vector(c :: List&lt;String&gt;):
    cases (List) c:
      | empty =&gt; empty
      | link(f, r) =&gt; link(count(f, lower-case(a)), vector(r))
    end
  end

  if (a == empty) or (b == empty):
    raise("Document is empty")
  else:
    total-uniq-words = L.distinct(lower-case(a) + lower-case(b)).sort()
    vector(total-uniq-words)
  end
where:
  create-vec([list: "a", "B", "c"], [list: "d", "d", "d", "b"]) is [list: 1, 1, 1, 0] 
  create-vec([list: "d", "d", "D", "b"], [list: "a", "b", "c"]) is [list: 0, 1, 0, 3]
  # sort test
  create-vec([list: "word"], [list: "words"]) is [list: 1, 0]
  create-vec([list: "w", "ww"], [list: "ww", "a", "w"]) is [list: 0, 1, 1] 
  # same document test
  create-vec([list: "a", "b"], [list: "a", "b"]) is [list: 1, 1]
  # handle empty case
  create-vec(empty, [list: "a"]) raises "Document is empty"
  create-vec([list: "a"], empty) raises "Document is empty"
end
</pre>

<p>
Internal tests of each helper function were removed so I didn't spam up the results with repeated tests. My design decision was to include all these within create-vec since they won't be reused so contained them all there. I use two calls to lower-case(a) which should just be one and result assigned to a variable to be reused instead of wasting resources but really this whole program can be a few lines anyway once we do the Higher-Order functions lab.
</p>
</div>
</div>

<div id="outline-container-Properties%20testing" class="outline-3">
<h3 id="Properties%20testing">Properties testing</h3>
<div class="outline-text-3" id="text-Properties%20testing">
<p>
How should we test the properties of create-vec, meaning forget about the specific test cases, what is the general properties/behavior/characteristics/structure of create-vec we can test? One property of create-vec should be the result is a list that equals the length of both it's inputs with duplicates removed. Another property of create-vec is the sum of the word frequency in the first input, should equal the sum of the returned vector.
</p>

<pre class="example" id="orgef3b8d0">
check:
  # we haven't done map/fold yet, you can rewrite them with cases (List) anyway
  
  # generate a list
  a = range(2, 15)

  # map over generated list, fill it with random strings
  # add 1 to num-random(500) to avoid empty string
  b = map(lam(x): string-to-lower(string-from-code-point(num-random(500) + 1)) end, a)

  # create the input the same way
  input = map(lam(x): string-to-lower(string-from-code-point(num-random(500) + 1)) end, a)

  # print the random inputs for debugging if tests fail
  print(input)  
  print(b)

  # test create-vec satisfies length property
  create-vec(input, b).length() is L.distinct(b + input).length()

  # fixed count function that should consume a code-point number
  fun count(c :: Number, d :: List&lt;String&gt;) -&gt; Number:
    doc: "Goes through all of list d and counts frequency of string code point c"
    cases (List) d:
      | empty =&gt; 0
      | link(f, r) =&gt; 
        if string-to-code-point(f) == c:
          1 + count(c, r)
        else:
          count(c, r)
        end
    end
  end

  # generate distinct list of both inputs
  master-list = L.distinct(input + b)

  # go through master-list, count the freq of input list
  test = map(lam(x): count(string-to-code-point(x), input) end, master-list)

  # test create-vec satisfies sum property 
  create-vec(input, b).foldl(lam(x, acc): acc + x end, 0) is test.foldl(lam(x, acc): acc + x end, 0)
end
</pre>

<p>
This sum property test I wrote found a bug, the count function I designed worked fine with any <a href="https://en.wikipedia.org/wiki/Code_point">ASCII</a> but did not use <a href="https://www.pyret.org/docs/latest/strings.html#%28part._strings_string-to-code-point%29">code points</a> so once I changed the inputs to random unicode the tests would sometimes fail with different sums, even though the other tests always passed. Once I changed count to only use code points, I no longer had to guess how the language would equate string == string as the equality of two code point numbers is more certain, and the tests now pass after I wrote another program to repeatedly test create-vec (offline, so I wouldn't eat up resources with CPO website).  
</p>

<p>
You finish this assignment the same way we made create-vec, write a bunch of examples for a dot-product function where it consumes two lists (vectors), and the program will write itself.
(f * input2.first) + dot-product(r, input2.rest).
</p>

<p>
Overlap use the provided test cases, two documents that are the same should have an overlap of 1, which the assignment defines for us as:
</p>

<pre class="example" id="org6c8d706">
# num-max and num-sqrt are built-ins
dot-product(doc1, doc2) /
num-max(num-sqrt(dot-product(doc1, doc1)) * num-sqrt(dot-product(doc1, doc1)),
dot-product(doc2, doc2) * num-sqrt(dot-product(doc2, doc2)))

# sqrt(thing) squared, is just (thing)
dot-product(doc1, doc2) /
num-max(dot-product(doc1,doc1), dot-product(doc2, doc2))
</pre>

<p>
The result you will have to use creative testing like declaring an arbitrary epsilon which is a very small number, like .0001 or as precise as you want, and subtracting the result of overlap from your estimated value and testing the result if it is within that epsilon displacement. Use num-abs to convert the result to an absolute value which just means it will always return a positive displacement. 
</p>
</div>
</div>
</div>

<div id="outline-container-Lab%3A%20Higher-Order%20Functions" class="outline-2">
<h2 id="Lab%3A%20Higher-Order%20Functions">Lab: Higher-Order Functions</h2>
<div class="outline-text-2" id="text-Lab%3A%20Higher-Order%20Functions">
<p>
Let's do the <a href="https://cs.brown.edu/courses/cs019/2016/hofs-lab.pdf">lab</a> on functions as data, and write our own map, filter and fold. 
</p>

<pre class="example" id="orgdb92ea8">
fun fun-plus-one(num :: Number, func :: (Number -&gt; Number)) -&gt; Number:
  func(num) + 1
end

&gt;&gt;fun-plus-one(16, num-sqrt)
&gt;&gt;5
&gt;&gt;fun-plus-one(3, num-sqr)
&gt;&gt;10
</pre>

<p>
Try entering various built-ins, or one you wrote yourself, as the second parameter to fun-plus-one. In case you get hung up on syntax 'func' parameter can by anything, and try manipulating the (Number -&gt; Number) annotation to ( -&gt; Number) or remove the annotation completely to (num, f) and the function still works. 
</p>

<p>
<b>Map</b>
</p>

<p>
We're given test cases and asked to implement f-to-c and goldilocks, and given the formula for f to c temperature unit conversion.
</p>

<pre class="example" id="orgfa71343">
fun f-to-c(f-lst :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt; 
      link((f - 32) * (5/9), f-to-c(r))
  end
end

fun goldilocks(f-lst :: List&lt;Number&gt;) -&gt; List&lt;String&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 90:
        link("too hot", goldilocks(r))
      else if f &lt; 70:
        link("too cold", goldilocks(r))
      else:
        link("just right", goldilocks(r))
      end
  end
end
check:
  f-to-c([list: 131, 77, 68]) is [list: 55, 25, 20]
  goldilocks([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
map(lam(x): x + 1 end, f-lst) the 'x' input is the element in each link in the list f-list, you are mapping over the whole list one element at a time and returning a new list. We are asked to implement goldilocks using map: 
</p>

<pre class="example" id="orgef3a976">
# lambda notation
fun goldilocks(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  f-lst.map(lam(x): if x &gt; 90: "too hot" else if x &lt; 70: "too cold" else: "just right" end end)
end
check:
  goldilocks([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end

# shorthand syntax for lambdas from lab documentation 
fun goldilocks2(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  f-lst.map({(x): if x &gt; 90: "too hot" else if x &lt; 70: "too cold" else: "just right" end})
end
check:
  goldilocks2([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
.map() is a built-in method on a list, where f-lst.map() means we are mapping over f-lst. We could have also rewritten it like the following example where we consume a function of type A (number) that produces a different type B (string, boolean):
</p>

<pre class="example" id="org31b1c82">
fun goldilocks(x :: Number) -&gt; String:
  if x &gt; 90:
    "too hot"
  else if x &lt; 70:
    "too cold"
  else:
    "just right"
  end
end

fun goldbool(x :: Number) -&gt; Boolean:
  if (x &gt; 90) or (x &lt; 70):
    false
  else:
    true
  end
end


fun generic-map&lt;A,B&gt;(f :: (A -&gt; B), f-lst :: List&lt;A&gt;) -&gt; List&lt;B&gt;:
  map(f, f-lst)
end
check:
  generic-map(goldilocks, [list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
  generic-map(goldbool, [list: 131, 77, 68]) is [list: false, true, false]
end
</pre>

<p>
Write our own version of map. I used the documentation examples for map as check tests. Remember map consumes a function and a list, applies the function to each entry in the list returning a new list, try to do this yourself before looking at a solution (your solution may be better). 
</p>

<pre class="example" id="org1907cf5">
fun my-map&lt;A,B&gt;(func :: (A -&gt; B), l :: List&lt;A&gt;) -&gt; List&lt;B&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(func(f), my-map(func, r))
  end
end
check:
  my-map(num-to-string, [list: 1, 2]) is [list: "1", "2"]
  my-map(lam(x): x + 1 end, [list: 1, 2]) is [list: 2, 3]
  my-map(lam(x): true end, [list: "test", "test2"]) is [list: true, true]
end
</pre>

<p>
<b>Filter</b>
</p>

<p>
First two assignments are straight forward to get you to used to using filter, except you have to use string-to-code-points() instead of any built-in string functions. 
</p>

<pre class="example" id="org21bd157">
fun tl-dr(lol :: List&lt;String&gt;, length-thresh :: Number) -&gt; List&lt;String&gt;:
  filter(lam(element): string-to-code-points(element).length() &lt;= length-thresh end, lol)
end
check:
  tl-dr([list: "dkfjdkj", "hi", "dkfjk"], 2) is [list: "hi"]
  tl-dr([list: "corner", "case", ""], 2) is [list: ""]
  tl-dr([list: "a", "b", "c"], 0) is empty
end

fun eliminate-e(words :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
  doc: "I got 101 and 69 from string-to-code-points(e) and (E)"
  filter(lam(x): not((string-to-code-points(x).member(101)) or 
      (string-to-code-points(x).member(69))) end, words)
end
check:
  eliminate-e([list: "e"]) is empty
  eliminate-e([list: "there's", "no", "letter", "e", "here"]) is [list: "no"]
  eliminate-e([list: "hEy", "101e"]) is empty
end
</pre>

<p>
Lambda parameters can be a single letter: filter(lam(x): x &gt; 1 end) as it's immediately evident what that parameter is and it's scope is limited though you can add annotations like lam(x :: Number). You can also ignore the parameter if you don't plan on using it replacing x with underscore. Task: implement our own version of filter, which is similar to what we did for map:
</p>

<pre class="example" id="org1b910ea">
fun my-filter&lt;T&gt;(func :: ( T -&gt; Boolean), l :: List&lt;T&gt;)-&gt; List&lt;T&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if func(f):
        link(f, my-filter(func, r))
      else:
        my-filter(func, r)
      end
  end
end
check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  my-filter(length-is-one, [list: "ab", "a", "", "c"]) is [list: "a", "c"]
  my-filter(is-link, [list: empty, link(1, empty), empty]) is [list: link(1, empty)]
  my-filter(lam(x): x &gt; 0 end, [list: 0, 1, -1]) is [list: 1]
end
</pre>

<p>
<b>Fold</b>
</p>

<p>
Try the two tasks: list-product and list-max:
</p>

<pre class="example" id="orgc97893f">
fun list-product(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): acc * n end, 1, lon)
end
check:
  list-product([list: 2, 2, 2]) is 8
  list-product([list: 0, 1, 2]) is 0
  list-product([list: -1, -1]) is 1
end
</pre>

<p>
There's a bug here to fix, try all negative examples
Found by <a href="https://github.com/rand-anon-007">https://github.com/rand-anon-007</a>
</p>
<pre class="example" id="org7cffb57">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): if n &gt; acc: n else: acc end end, 0, lon)
end
check:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
end
</pre>

<p>
The problem is the accumulator needs to be initialized with the first value of the list not 0:
</p>

<pre class="example" id="org8e379b8">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3]) is -1
  list-max([list: 0]) is 0
# list-max(empty) what about this case?
end
</pre>

<p>
Then we come to another problem, what if the list is empty then long.get(0) returns an error:
</p>

<pre class="example" id="orgb1f8e74">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  if lon == empty:
    0 # is this correct?
  else:
    fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
  end
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3])  is -1
  list-max(empty) is 0
end
</pre>

<p>
Now we have to make design decisions, should it eval to 0 for empty since the max of an empty list is nothing or should it raise an error?
</p>

<pre class="example" id="orgde7256a">
fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  if lon == empty:
    raise("List can't be empty")
  else:
    fold(lam(acc, n): if n &gt; acc: n else: acc end end, lon.get(0), lon)
  end
where:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
  list-max([list: -1, -2, -3])  is -1
  list-max(empty) raises "List can't be empty"
end
</pre>

<p>
Write your own fold 
</p>

<pre class="example" id="org6492140">
fun my-fold&lt;A,B&gt;(func :: (B, A -&gt; B), acc :: B, l :: List&lt;A&gt;) -&gt; B:
  cases (List) l:
    | empty =&gt; acc
    | link(f, r) =&gt;
      my-fold(func, func(acc, f), r)
  end
end
check:
  my-fold((lam(acc, elt): acc + elt end), 0, [list: 3, 2, 1]) is 6
  # set accumulator to something not 0
  my-fold((lam(acc, elt): acc + elt end), 10, [list: 3, 2, 1]) is 16

  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end

  my-fold(combine, "END", [list: 3, 2, 1]) is "1 - 2 - 3 - END"
  my-fold(combine, "END", empty) is "END"
end
</pre>

<p>
That type signature func :: (B, A -&gt; B) means the function you are taking as input has 2 parameters, since fold has an accumulator. My implementation of fold the first parameter <i>func :: (B, A -&gt; B)</i> is a placeholder to remember what function was input, and <i>acc :: B</i> is the accumular after I apply func(acc, f) it produces a value that needs to be tracked through each recursive call on rest of list. 
</p>

<p>
<b>Map2</b>
</p>

<p>
Try the task for implementing who-passed, the second task we're asked to write map2 ourselves. 
</p>

<pre class="example" id="orgd476ef2">
# link(ff, rr) and link(f, r) can be called anything:
# ie: link(head-first, tail-first) or link(head-second, tail-second)

fun my-map2&lt;A,B&gt;(func :: (A, A -&gt; B), list1 :: List&lt;A&gt;, list2 :: List&lt;A&gt;) -&gt; List&lt;B&gt;:
  cases (List) list1:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) list2:
        | empty =&gt; empty
        | link(ff, rr) =&gt;
          link(func(f, ff), my-map2(func, r, rr))
      end
  end
end
check:
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(_ + _, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune"])
    is [list: "misfortune"]
  my-map2(string-append, [list: "mis", "mal"], empty)
    is empty
  # test type signature
  my-map2(lam(x, y): if (x &gt; 0) and (y &gt; 0): true else: false end end, [list: 0, 1], [list: 2, 3]) 
    is [list: false, true] 
end
</pre>

<p>
The last task, best-price, look on youtube what a basic demand function is. Here's an example:
</p>

<pre class="example" id="orga8665ba">
fun demand(price-increase :: Number) -&gt; Number:
 doc: "1000 is approx demand of product at a fixed price"
  1000 - (60 * price-increase)
end
</pre>

<p>
This means as the price increases, the quantity demanded will decrease by 60 units times the price increase, so if the price increase is 1, the demand is 1000 - 60. Your best-price function can take a list of price increases, the demand function, then map over the price list w/the demand function, to get a new list of adjusted demand vs price increase. Map over the adjusted demand with the price list to produce the forecast revenue, which is price * qty demanded. Then figure out how to use a combo of filter/fold in order to return the optimal price increase.
</p>

<p>
<b>Map vs Filter vs Foldl vs Foldr</b>
</p>

<p>
map and filter only consider one item at a time whereas fold can consider the entire list. You can implement both map and filter with fold (try it). If you've noticed in the Pyret documentation there is foldl and foldr:
</p>

<pre class="example" id="org867e8be">
import lists as L

L.foldl(lam(acc, x): acc + x end, 0, [list: 1, 2, 3])
# (((0 + 1)+ 2)+ 3)
# eval nested brackets first, left to right

L.foldr(lam(acc, x): acc + x end, 0, [list: 1, 2, 3])
# (1 +(2 +(3 + 0)))
# eval nested brackets right to left
</pre>

<p>
Here's an example of why you'd want to use foldr, making your own map function:
</p>

<pre class="example" id="org7313c8c">
import lists as L

fun my-map&lt;A,B&gt;(func :: (A -&gt; B), list1 :: List&lt;A&gt;) -&gt; List&lt;B&gt;:
  L.foldr(lam(acc, x): link(func(x), acc) end, empty, list1)
where:
  my-map(num-to-string, [list: 1, 2]) is [list: "1", "2"]
  my-map(lam(x): x + 1 end, [list: 1, 2]) is [list: 2, 3]
  my-map(lam(x): true end, [list: "test", "test2"]) is [list: true, true]
end
</pre>
</div>

<div id="outline-container-PAPL%20chapter%2011%20%2FStructured%20Data%2F" class="outline-3">
<h3 id="PAPL%20chapter%2011%20%2FStructured%20Data%2F">PAPL chapter 11 <i>Structured Data</i></h3>
<div class="outline-text-3" id="text-PAPL%20chapter%2011%20%2FStructured%20Data%2F">
<p>
We are almost caught up the course now, imagine if you took this course for credit how much work you'd have to put in the first 2 weeks to keep up. This is why it is called 'accelerated'. Here we learn what a data definition is which we saw a little of in the first lecture. <a href="https://papl.cs.brown.edu/2020/intro-struct-data.html">Reading</a> <i>Introduction to Structured Data</i>. We're making our own types here and doing cases on our custom types instead of Lists.
</p>

<p>
In 11.3.2 try commenting out one of the cases from fun advice(c :: TLColor). If you click <i>Run</i> nothing happens, however if you change it to <i>Type-Check and Run</i> CPO will error that the cases expression should be able to handle all possible values of TLColor, but its branches cannot handle one of the variants. 
</p>
</div>
</div>
</div>

<div id="outline-container-Assignment%202%3A%20Nile" class="outline-2">
<h2 id="Assignment%202%3A%20Nile">Assignment 2: Nile</h2>
<div class="outline-text-2" id="text-Assignment%202%3A%20Nile">
<p>
After this assignment we are caught up to where students are currently at in the lectures. Here we are restricted from using list built-ins, so member, append, or distinct you'll have to write these yourself. The instructor considers rewriting library functions as drill exercises since programming is learn by doing. We need to fill in recommend and popular-pairs according to the <a href="https://cs.brown.edu/courses/cs019/2019/nilenile.html">spec</a> we're given. Don't use their 2018 starter template, there's some kind of bug where accessing the content of a recommendation doesn't work. Write your own or use <a href="https://code.pyret.org/editor#share=0Bxr4FfLa3goOMmI2RnlkWUhCTzA">this</a>:
</p>

<pre class="example" id="org20874ad">
provide *
provide-types *

data Recommendation&lt;A&gt;:
  | recommendation(count :: Number, content :: List&lt;A&gt;)
end

data File:
  | file(name :: String, content :: String)
end

fun recommend(title :: String, book-records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in the title of a book and a list of files,
       and returns a recommendation of book(s) to be paired with title
       based on the files in book-records.```
  recommendation(0, empty)
end

fun popular-pairs(records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in a list of files and returns a recommendation of
       the most popular pair(s) of books in records.```
  recommendation(0, empty)
end
</pre>

<p>
Examples to help understand what the assignment is asking for, you can run this to see if the tests are at least well formed:
</p>

<pre class="example" id="org6c90915">
fun recommend(title :: String, book-records :: List&lt;File&gt;) -&gt; Recommendation:
  doc: ```Takes in the title of a book and a list of files,
       and returns a recommendation of book(s) to be paired with title
      based on the files in book-records.```
  recommendation(0, empty)
where:
  r1 = file("a", "1984\nCrime and Punishment\nHeaps are Lame\nLord of the Flies")
  r2 = file("b", "1984\nHeaps are Lame\nLord of the Flies")
  r3 = file("c", "1984\nCrime and Punishment\nHeaps are Lame\nCalculus")
  r4 = file("d", "Crime and Punishment\n1984\nLord of the Flies")
  input = [list: r1, r2, r3, r4]

  recommend("1984", input) is recommendation(3, [list: "Heaps are Lame", "Crime and Punishment", "Lord of the Flies"])
  recommend("Heaps are Lame", input) is recommendation(3, [list: "Crime and Punishment", "1984", "Lord of the Flies"])
  recommend("War", [list: file("q", "War\nPeace")]) is recommendation(1, [list: "Peace"])
  recommend("PAPL", input) is  recommendation(0, empty)
 

  # These are their tests from 2016 Nile writeup:
  f1=file("alist.txt","1984\nAnimal Farm\nHigurashi\nLife of Pi")
  f2=file("blist.txt","Animal Farm\nHigurashi\nLife of Pi")
  f3=file("clist.txt","1984\nHeart of Darkness")
  input2 = [list: f1, f2, f3]

  recommend("1925", input2) is recommendation(0,[list: ])
  recommend("1984", input2) is recommendation(1,[list: "Animal Farm","Higurashi","Life of Pi","Heart of Darkness"])
end
</pre>

<p>
The input is [list: file, file, file], so we need to map over that list, extract the file.content book titles, remove the newline "\n" somehow, put everything in a new list and then count the freq like we did in DocDiff. You could append "\n" as a sentinel to the end of file.content string as per lecture 2 Rainfall Problem then filter it out, or write a function the turns every string character into a giant list of code points, then fold over it using an accumulator to reassemble the strings, truncating them on the newline sentinel. Whatever you decide to do make sure you hand roll the library functions you want (except fold/map/filter, you already hand rolled those) this drill will help you in future lectures and assignments.
</p>
</div>

<div id="outline-container-popular-pairs%28%29" class="outline-4">
<h4 id="popular-pairs%28%29">popular-pairs()</h4>
<div class="outline-text-4" id="text-popular-pairs%28%29">
<p>
Using the 2019 <a href="https://cs.brown.edu/courses/cs019/2019/nilenile.html">Nile</a> assignment spec:
</p>

<pre class="example" id="org1d0d729">
data BookPair:
    | pair(book1 :: String, book2 :: String)
end

input = [list: file("alist.txt", "1984\nAnimal Farm\nHigurashi\nLife of Pi"),
               file("blist.txt", "Animal Farm\nHigurashi\nLife of Pi"),
               file("clist.txt", "1984\nHeart of Darkness")]

# recommend("1984", input) returns:
# recommendation(2, [list: "Animal Farm", "Higurashi", "Life of Pi"] 

recommendation(2, [list: pair("Animal Farm","Higurashi"), pair("Animal Farm", "Life of Pi"), pair("Higurashi", "Life of Pi")])
</pre>

<p>
Example writing helps here again to figure out how you should pair the results. Notice that Recommendation&lt;A&gt; is polymorphic, so we can change List&lt;String&gt; to List&lt;BookPair&gt; and get Recommend&lt;BookPair&gt; without having to alter the data definition.
</p>

<p>
Something to try, think about testing the properties of pairing: a recommendation of 3 titles should have 3 pairings. 4 titles has 6 pairings. 5 titles has 9 pairings. 
</p>
</div>
</div>
</div>

<div id="outline-container-Lecture%204%20Big-O" class="outline-2">
<h2 id="Lecture%204%20Big-O">Lecture 4 Big-O</h2>
<div class="outline-text-2" id="text-Lecture%204%20Big-O">
<p>
We caught up to the class, you can compare dates of lectures with <a href="https://cs.brown.edu/courses/cs019/2018/assignments.html">dates</a> of due assignments. Watching the Fri 9/14/18 lecture on performance. The setup in the beginning of the lecture is to distinguish the notation in O(n) as being a function that maps from n -&gt; steps to complete computation. Another explanation is <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#%28part._.Ambiguities_in_mathematics%29">here</a> in <i>ambiguities in mathematics</i>.  
</p>

<p>
The constant mentioned at the end of the lecture in the formal notation is further exampled <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#%28part._.A_formal_definition%29">here</a>. It's an estimation constant that bounds f, so no matter what input to f(k), a constant c times g(k) will be bigger or equal to it. What times g(k) is bigger or equal to f(k) -&gt; 5k + 4:
</p>

<ul class="org-ul">
<li>f(k) -&gt; 5k + 4:
<ul class="org-ul">
<li>f(1) -&gt;  5(1) + 4 = 9</li>
<li>f(2) -&gt;  5(2) + 4 = 14</li>
<li>f(3) -&gt;  5(3) + 4 = 19</li>
<li>f(10) -&gt; 5(10) + 4 = 54</li>
</ul></li>

<li>g(k) -&gt; k:
<ul class="org-ul">
<li>g(1) = 1</li>
<li>g(2) = 2</li>
<li>g(3) = 3</li>
</ul></li>
</ul>

<p>
The constant c, try 10 as suggested in the lecture for f([k -&gt; 5k + 4]) is \(\le\) (10 * g([k -&gt; k])):
</p>

<ul class="org-ul">
<li>f(1) is 9</li>
<li>g(1) -&gt; 10 * 1 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
<li>f(2) is 14</li>
<li>g(2) -&gt; 10 * 2 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
<li>f(10) is 54</li>
<li>g(10) -&gt; 10 * 10 
<ul class="org-ul">
<li>f &lt; g</li>
</ul></li>
</ul>
</div>


<div id="outline-container-PAPL%20Chapter%2017%20%2FPredicting%20Growth%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2017%20%2FPredicting%20Growth%2F">PAPL Chapter 17 <i>Predicting Growth</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2017%20%2FPredicting%20Growth%2F">
<p>
17.5 <i>structural recursion</i> can be described as you have built up a structure like say a list, adding n + 1 elements and structural recursion is taking that structure apart in the same way you built it up, which in a list example is n - 1 elements at a time. <i>Generative</i> recursion rearranges a problem into a set of new generated problems, basically recursion that <a href="https://htdp.org/2018-01-06/Book/part_five.html">ignores structure</a>. Quick sort is an example of generative recursion you break on a pivot and now have 2 lists plus the pivot, that's not how you assembled that list structurally (there are lectures for quick sort shortly). 
</p>

<p>
The Tabular Method, is not necessary as you will read in 17.8 since we can hand count these functions like we learned in the lecture. The 'question' refers to the conditionals in the cases statement like empty? link? and the answer is what that field in the cases statement evaluates to, like 0 for empty length or the recursive call in link(f, r). 
</p>

<p>
"<i>Let's consider the first row. The question costs three units (one each to evaluate the implicit empty-ness predicate, l, and to apply the former to the latter)</i>" which is a very difficult way of saying: calling the function is +1 cost, opening up l for cases is +1, considering empty variant is +1, so 3 in total and once more if the list is actually empty which you should remember from lecture 4 Fri/9/14/18. Second row cost calculation is different from the lecture (none of these tiny costs matter of course), We get to link(f, r) and count: link +1, f +1, rest +1, 2 more for the addition operation, and +1 to call len() again, so total 6 for the 'answer' though the lecture we saw is +1 for link, +1 for addition, and plus (k - 1), so in the lecture len() is total 5k + 4, here it's 12k + 4. You can do either this tabular method or you can do the adhoc assign +1 cost to anything that looks like an operation that we did in the lecture and you will end up with O([k -&gt; k]) anyway since we don't care about constants. 
</p>

<p>
17.7 We've seen this notation in lectures, they are lambda functions to remove ambiguities of math notation. 17.8 recall from lectures that in english reads: 'there exists some constant C, for all inputs n in the set of natural numbers to the function f(n) such that f(n) is less or equal to this same constant C multiplied by some other function g(n) implying that f() is bounded by g(). 
</p>

<p>
17.8 Let's find the smallest constant for 13k + 4 \(\le\) ck<sup>2</sup>. If k = 1 then c needs to be 17 or larger. If k = 2 then we have 30 \(\le\) 17(2<sup>2</sup>) which is true, and also true for k = 3, k = 4, if k = a trillion then 13(1 trillion) + 4 is still less than 17(1 trilllion * 1 trillion) in fact for inputs bigger than 13 the constant c becomes irrelevant. <a href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation">Big theta</a> is then discussed briefly as the family of functions that grow at the same speed up to a constant. Reading PAPL, if you want to understand the math notation right click it, or if on a phone press the notation, in most browsers you should get a menu popping up from MathJax to show the TeX code to see exactly what it is. 
</p>

<p>
17.9 <i>Combining Big-oh Without Woe</i> two functions in O(n) run consecutively (one after the other) are O(n + n) or O(2n) which is O(n) since constants don't matter, like f(5k + 4) is really f(k). A function f(n) that invokes z(n) in each of it's steps is O(n x n) or O(n<sup>2</sup>). 
</p>
</div>

<div id="outline-container-17.10%20Solving%20recurrences" class="outline-4">
<h4 id="17.10%20Solving%20recurrences">17.10 Solving recurrences</h4>
<div class="outline-text-4" id="text-17.10%20Solving%20recurrences">
<p>
The first recurrence example of T(k) = T(k - 1) think of the lecture when we went through length(), which was a constant amount of 5 steps per input, plus everything that came before it, so 5 + (k-1) + 4 with the + 4 being the empty case, that's the same as T(k - 1) + c. The notation T(k - 2), T(k - 3) is referring to the next steps down the recursion tree towards the base case. Here \(c_0\) or \(c_1\) are used to show the base case is either 0 or 1 (the empty/stop recursion case). If you want go through this set of YouTube <a href="https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw/search?query=recurrence">examples</a> on recurrence relations to see what a recursion tree looks like.  
</p>

<p>
The next recurrence is T(k-1) plus k, not a constant. To understand the notation: \(T(0) + (k-(k-1)) + (k-(k-2)) + \cdots + (k-2) + (k-1) + k\) plug in a value for k:
</p>

<ul class="org-ul">
<li>T(4) = T(0) + T(4-(4-1)) + T(4-(4-2)) + T(4-1) + T(4)</li>
<li>0 + 1 + 2 + 3 + 4</li>
<li>4(4+1)/2 = 10 is the closed form solution and is in O(\(n^2\)) since n(n + 1)/2 = (n<sup>2</sup> + n)/2.</li>
</ul>

<p>
2T notation means there are two recursive calls. The last recurrence relation is detailed in this <a href="https://www.youtube.com/watch?v=JvcqtZk2mng">YouTube</a> example.    
</p>

<p>
There's an induction exercise which you can try if you've followed the math workshop with this one: 
</p>

<ul class="org-ul">
<li>T(n) = n(n + 1)/2</li>
<li>Base Case:
<ul class="org-ul">
<li>T(1) = 1(1 + 1)/2 or 2/2</li>
<li>T(1) = 1</li>
</ul></li>
<li>Hypothesis:
<ul class="org-ul">
<li>Suppose that T(n) = n(n + 1)/2 (assumption)</li>
</ul></li>
<li>Then it is true for n + 1:
<ul class="org-ul">
<li>T(n) + (n + 1) = (n + 1)((n + 1) + 1)/2</li>
<li>T(n) + (n + 1) = (n + 1)(n + 2)/2</li>
</ul></li>
<li>Left side is in the form of hypothesis T(n):
<ul class="org-ul">
<li>n(n + 1)/2 + (n + 1) = (n + 1)(n + 2)/2</li>
</ul></li>
<li>Let's get rid of the denominator 2 by multiplying both sides by 2/1 
<ul class="org-ul">
<li>n(n + 1) + 2(n + 1) = (n + 1)(n + 2)</li>
<li>\(n^2\) + 3n + 2 = (n + 1)(n + 2)</li>
</ul></li>
<li>Factor left side:
<ul class="org-ul">
<li>(n + 1)(n + 2) = (n + 1)(n + 2)</li>
</ul></li>
</ul>

<p>
We will come back to this chapter after next lecture to figure out the [k -&gt; log k] and other logarithmic time algorithms. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-Lecture%205%20Insertion%20Sort%20Reccurrence" class="outline-2">
<h2 id="Lecture%205%20Insertion%20Sort%20Reccurrence">Lecture 5 Insertion Sort Reccurrence</h2>
<div class="outline-text-2" id="text-Lecture%205%20Insertion%20Sort%20Reccurrence">
<p>
We're watching the Mon9/17/18 lecture. The first 30mins or so of the recording doesn't have video, but you can pause the video around 30:14 in, open the video again to hear the audio, and see everything on the board they are working on (sort and insert). He starts out talking about the invariant of insert, that it's length should always be k+1 because it is inserting a new value. The second topic is about how the size argument of a list doesn't help you with incorrect types, if you have [list: [list: empty]], that's still size = 1 even though it's empty. 
</p>

<p>
The if-statement you take the worst complexity branch, assuming worse-case analysis. The actual cost analysis of insert() starts around 20mins in because you want to resolve the dependencies of sort() by figuring out the complexity class of insert() first. A link operation link(f, r) takes a constant amount of time regardless of the size of the input list, because it doesn't make a copy of the list. The if statement is 1 + (worst case branch). 
</p>

<p>
On the right hand of the board:
</p>
<ul class="org-ul">
<li>Tinsert(0) = \(c0\) (constant steps for empty, or base case)</li>
<li>Tinsert(k) = c + Tinsert(k - 1)</li>
<li>= c + c + c + &#x2026; \(c0\)</li>
<li>= T(k) = kc + \(c0\).</li>
</ul>

<p>
Remember we're calling insert(f, sort(r)) on the rest of the list, so it's k - 1. 
</p>

<ul class="org-ul">
<li>Tsort(0) = \(c_0\) or a constant amount of steps</li>
<li>Tsort(k) = Tsort(k - 1) + Tinsert(k - 1)c + \(c_0\)</li>
<li>= Tsort(k - 1) + kc</li>
<li>We've seen this already, T(k - 1) + k is the series 1 + 2 + 3 + 4+&#x2026;+(k - 1) + k or n(n + 1)/2 or \(O(n^2)\)</li>
<li>Insertion Sort is \(O(n^2)\) worst case, and O(n) + O(1) in the best case because you still have to call sort(r) and do linear work exploding that n sized list out before you can do the O(1) operation by insert that appends to the beginning of the list and returns.</li>
</ul>
</div>


<div id="outline-container-More%20Recurrences" class="outline-3">
<h3 id="More%20Recurrences">More Recurrences</h3>
<div class="outline-text-3" id="text-More%20Recurrences">
<p>
Before we look at the big-O lab let's learn some more about recurrences so we 'can feel them in our bones' as suggested by Prof K in the last lecture. I'm going to use Part V <i>Recurrences</i> from MIT's <a href="https://courses.csail.mit.edu/6.042/spring18/mcs.pdf">Mathematics for Computer Science(mcs)</a> free book, starting on page 993 and read only up to page 1001 as cs19 will cover the analysis later (Akra-Bazzi formula/asymptotic solution) in future lectures. For now we're going to read the intro of the Tower of Hanoi, and the steps they do to solve the recurrence for merge sort. 
</p>

<p>
There are <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/lecture-14-divide-and-conquer-recurrences/">lectures</a> for the recurrence chapter of mcs, the inductive proof in the recorded lecture for the Tower of Hanoi recurrence is slightly different than the pdf:
</p>

<ul class="org-ul">
<li>Our original recurrence: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>Inductive Hypothesis(IH)/closed form solution: \(T_n\) = \(2^n\) - 1</li>
<li>Base Case: \(T_1\) = \(2^1\) - 1</li>
<li>Inductive step: \(T_{n+1}\) = 2\(T_{(n-1) + (n+1)}\) + 1 or 2\(T_n\) + 1</li>
<li>"Suppose \(T_n\) = \(2^n\) - 1. Then the successor of \(T_n\) is \(T_{n+1}\) = \(2^{n+1}\) - 1"</li>
<li>Now via substitution plug in our inductive hypothesis, since we declared \(T_n\) = \(2^n\) - 1 wherever you see \(T_n\) insert that hypothesis:
<ul class="org-ul">
<li>\(T_{n+1}\) = 2\(T_n\) + 1</li>
<li>\(T_{n+1}\) = 2(\(2^n\) - 1) + 1 (substitution)</li>
<li>\(T_{n+1}\) = \(2^{n+1}\) - 2 + 1 (distributive law)</li>
<li>\(T_{n+1}\) = \(2^{n+1}\) - 1</li>
</ul></li>
</ul>

<p>
In mcs (the pdf text), for their IH they assumed that \(T_{n-1}\) = \(2^{n-1}\) - 1, so instead of substituting for \(T_n\) they substituted \(T_{n-1}\):
</p>

<ul class="org-ul">
<li>Original recurrence: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>Assume/IH: \(T_{n-1}\) = \(2^{n-1}\) - 1</li>
<li>Inductive step (looking at the left side) from \(T_{n-1}\) to \(T_{n++}\) becomes \(T_n\), and we already know the value: \(T_n\) = 2\(T_{n-1}\) + 1</li>
<li>By substitution replace all occurrences of \(T_{n-1}\) with IH:
<ul class="org-ul">
<li>\(T_n\) = 2(\(2^{n-1}\) - 1) + 1</li>
<li>\(T_n\) = \(2^n\) - 2 + 1</li>
<li>\(T_n\) = \(2^n\) - 1</li>
</ul></li>
</ul>

<p>
In <i>Merge Sort</i>, \(T_n\) describes two recursive calls, with the total input divided in half between them, plus another recursive call to compare each list and produce the smaller value (merging). The plug and chug method they use is self explanatory until Step 3 where they introduce k = log n in order to get their base case of \(T_1\) = 0. When you see \(2^k\) anywhere in the recurrence replace it with \(2^{\log n}\) which is n because \(a^{\log b}\) = \(b\). What you should take away from step 3 is how they manipulate the recurrence in order to produce a known value of \(T_n\) such as \(T_0\) or \(T_1\) in this case.
</p>


<p>
Step 3, after k = log n has been substituted for all k:
</p>
<ul class="org-ul">
<li>\(2^{\log n}T_{n/2^{\log n}}\) + log n * n - \(2^{\log n}\) + 1
<ul class="org-ul">
<li>Remember \(2^{\log n}\) = n</li>
</ul></li>
<li>n\(T_{n/n}\) + n * log n - n + 1
<ul class="org-ul">
<li>n\(T_{n/n}\) is n\(T_1\) and in step 3 \(T_1\) was already declared to be 0</li>
</ul></li>
<li>n(0) + n * log n - n + 1</li>
<li>n log n - n + 1 or \(T_n \in O(n \log n)\)</li>
</ul>
</div>
</div>

<div id="outline-container-Return%20to%2017.10%20Recurrences" class="outline-3">
<h3 id="Return%20to%2017.10%20Recurrences">Return to 17.10 Recurrences</h3>
<div class="outline-text-3" id="text-Return%20to%2017.10%20Recurrences">
<p>
Let's go back and <a href="https://papl.cs.brown.edu/2019/predicting-growth.html">read</a> 17.10 <i>Solving Recurrences</i> again now that we know how logarithms are used to produce a known base case value, like \(T_1\). The first is T(k) = T(k/2) + c or [k -&gt; log k] recurrence, we are looking at binary search. For this binary search example, note the trick to make this recurrence \(T_1\) and look up how the logarithms are <a href="https://en.wikipedia.org/wiki/Logarithm#Definition">defined</a> for \(log_2\) k. 
</p>

<p>
The next example T(k) = T(k/2) + k or [k -&gt; k], again they have used the \(2^{\log k}\) trick to produce k/k, and they have also used the distributive property to factor out k producing k(1/k + &#x2026;+ 1/4 + 1/2 + 1) which ends up simplifying to base case 1 constant + 2k. The [k -&gt; k log k] example they get rid of \(2^k\) by replacing it with \(2^{\log k}\) which is k and this is multiplied by T(1) which is \(c_1\). The rest of the recurrence is k \(\log_2\) k which is exampled and explained in this article on <a href="https://en.wikipedia.org/wiki/Logarithm#Product,_quotient,_power,_and_root">power rule</a>. \(\log_2 k^k\) is k \(\cdot\) \(log_2\) k or k.  
</p>
</div>
</div>

<div id="outline-container-Lab%3A%20Big-O%201" class="outline-3">
<h3 id="Lab%3A%20Big-O%201">Lab: Big-O 1</h3>
<div class="outline-text-3" id="text-Lab%3A%20Big-O%201">
<p>
Let's go through the lab <a href="https://cs.brown.edu/courses/cs019/2016/bigO-lab.pdf">here</a>. 
</p>

<p>
First task, why can we disregard constants, we already know why, because g(x) = 5x<sup>2</sup> + x is T(k) = T(k-1) + n which is O[k -&gt; k<sup>2</sup>]), since we only care (in this class anyway) about finding an upper bound for the worse case, we don't care about the constant 5 or x as they are both bound by x<sup>2</sup>. We've seen how when inputs grow large, x<sup>2</sup> grows so much that any constants are insignificant numbers (solely for worse case analysis of course).  
</p>

<p>
Second task in the chapter <i>Notation</i> the brackets are needed if using the [k -&gt; k] notation and is why the first example of O(w -&gt; w<sup>3</sup>) is wrong, it should be f \(\in\) O([w -&gt; w<sup>3</sup>]). There also shouldn't be any constants in the notation like [m -&gt; 3m]. The example of f \(\in\) O(h<sup>2</sup>) should likely be f \(\in\) O([h -&gt; h<sup>2</sup>]) or f(h) \(\in\) O(h<sup>2</sup>). 
</p>

<p>
In 3 <i>The Tabular Method</i> we finally get an explanation what the terms 'question' and 'answer' mean, this should probably be in the book. The second row of the cases statement we already read in the book for len function, and saw it in lectures. It really doesn't matter how you count the constant units either for worse case analysis, in lectures we chose link(f, r) as +1 cost, the addition as +1 cost, and added it to 3k + 4 so total 5k + 4. If you carefully counted each operation in link and came up with 100k + 4 it'd still be the same worst case analysis of len() is in O([k -&gt; k]). Looking back at chapter <a href="https://papl.cs.brown.edu/2018/predicting-growth.html#%28part._solving-recurrences%29">17</a> T(k) = T(k - 1) + c recurrence is the same as len(). 
</p>


<p>
4 <i>Big-O with less math</i> explains how to estimate complexity a little more clearly than the book does. Task:
</p>


<ul class="org-ul">
<li>1: This could be [k -&gt; k * log k] because for each element we make a call to another function so O(F X G). This also fits the explanation of f(x) = x log x where the recursive call is logarithmic but input stays the same.</li>
<li>2: A linear function k does linear work 10x, then calls another linear function so [n -&gt; n + m] which is [n -&gt; n]</li>
<li>3: A linear function calls a quadratic function on every element, so [k -&gt; k * m<sup>2</sup>] or since these variables don't matter [k -&gt; k<sup>3</sup>]</li>
<li>4: At every linear step, remove is called on an entire list which must linearly search through list l and remove f, I'm guessing this is O(F X G) again.</li>
</ul>

<p>
Let's figure out 5, a function that takes as input 2 lists and counts their length. This translates to two nested cases:
</p>

<pre class="example" id="orge1b0c89">
fun dbl-count(list1, list2):
 cases (List) list1:
  | empty =&gt; 0
  | link(f1, r1) =&gt;
 cases (List) list2:
  | empty =&gt; 0
  | link(f2, r2) =&gt; 1 + dbl-count(r1) + 1 + dbl-count(r2)
  end
 end
end   
</pre>

<p>
Looking at chapter 17 in the book, this is T(k) = 2T(k - 1) + c. Two recursive calls each doing a constant amount of work. Let's confirm by watching <a href="https://youtu.be/JvcqtZk2mng">T(n)=2T(n-1)+1</a>. Indeed this is O([k -&gt; k<sup>k</sup>]).
</p>

<ul class="org-ul">
<li>6: My guess is that this is O(F(k) X G(k) X H(k<sup>2</sup>)) or O([k -&gt; k<sup>4</sup>])</li>
<li>7: Recall from lectures that you figure out complexity cost of dependent functions from the function dependencies up, so we want to find the cost for rem-helper() first. It takes a size k input, and an element from rem-dups. We have an if-branch so we take the worst branch, and both branches involve going linearly through the entire list and looking at every element. We'll just naively calculate some costs: We go into the function, +1, we open the list, +1, we look at empty case, +1, it is empty and we return empty so 3k + 1. If it's not empty +1 for link operation, +1 to compare f to c, and worst case I guess is +1 to link f then + all the previous operations all over again until empty. So this is k + constant or O([k -&gt; k]). Let's look at rem-dups. It's doing linear work up until it calls rem-helper() on every single element. The definition of Quadratic: 'appears when comparing each element of a data structure to all other elements in that structure' seems to fit this situation, so O([k -&gt; k<sup>2</sup>]). Looking in the book, we see T(k) = T(k - 1) + k describes this program as well.</li>
</ul>

<p>
5.1 <i>Solving Recurrences</i> recall \(c_0\) represents the base case T(0) which is some constant amount of work. 
</p>

<p>
Another task, find the closed form of T(k-2) + 1 if k &gt; 1. There's a lecture for <a href="https://www.youtube.com/watch?v=8gt0D0IqU5w">this</a>. Second recurrence relation: 2T(k-1) + 1 for k &gt; 0 we already did, it's O([k -&gt; k<sup>k</sup>]). The extra challenge relations are all in the book and lectures to solve these exist in this guy's <a href="https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O">playlist</a> under 2.1.1 - 2.3.3.
</p>

<p>
You now have a good enough Big-O background until you decide to learn more about complexity theory and best-case/average-case analysis. 
</p>
</div>
</div>
</div>


<div id="outline-container-Lecture%206%20Quicksort" class="outline-2">
<h2 id="Lecture%206%20Quicksort">Lecture 6 Quicksort</h2>
<div class="outline-text-2" id="text-Lecture%206%20Quicksort">
<p>
We're watching the lecture titled Wed9/19/18. Reminder these lectures can be viewed or downloaded in 1920x1080 size so you can zoom with whatever video player if needed but seeing the fine details isn't important he is showcasing the structure of linear [k -&gt; k] vs quadratic [k -&gt; \(k^2\)].  
</p>

<p>
He remarks that their quicksort implementation is really a filter, and we should try quicksort using a built-in. Let's try it:
</p>

<pre class="example" id="org95e922f">
fun combine(lt, p, gt):
  lt.append([list: p]).append(gt)
end

fun qsort(l):
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        qsort(r.filter(lam(n): n &lt; pivot end)),
        pivot,
        qsort(r.filter(lam(n): n &gt;= pivot end)))
  end
end
check:
  qsort([list: 2, 1, 3, 4, 5]) is [list: 1, 2, 3, 4, 5]
  qsort([list: 100, 0, 1, 343]) is [list: 0, 1, 100, 343]
  qsort([list: 0, -1, 100]) is [list: -1, 0, 100]
  qsort([list: ]) is ([list: ])
  qsort([list: 8, 1, 1, 9, -1]) is [list: -1, 1, 1, 8, 9]
end
</pre>

<p>
He ends the lecture trying to convey a bigger idea: use the structure of the data to come up with a simple solution, confirm the inefficient solution is correct, optimize it according to the bound you want. 
</p>
</div>
</div>


<div id="outline-container-Assignment%203%3A%20Sortacle" class="outline-2">
<h2 id="Assignment%203%3A%20Sortacle">Assignment 3: Sortacle</h2>
<div class="outline-text-2" id="text-Assignment%203%3A%20Sortacle">
<p>
This assignment we're building a testing oracle.
</p>

<p>
First function is generate-input(n :: Number) -&gt; List&lt;Person&gt;, it consumes a number, and produces a list of length n of type Person. Since this function is going to generate random person.name strings we can't directly match the output in a test case, but we can still confirm it has the correct properties of [list: person(name, number)]:
</p>

<pre class="example" id="org33c4680">
data Person:
  | person(name :: String, age :: Number)
end

fun generate-input(n :: Number) -&gt; List&lt;Person&gt;:
  doc:"Generate random n size list of person(name, age), name is length 4, age is 1 - 100"
  ...
where:
  # confirm size
  L.length(generate-input(5)) is L.length([list: 1, 2, 3, 4, 5])
  map(lam(x): (string-length(x.name) &gt; 0) is true end, generate-input(5))  

  # make sure the age &gt; 0
  map(lam(x): x.age &gt; 0 is true end, generate-input(5))
 
 # confirm name is ASCII code points from 97 - 122 
 # string-to-code-points() returns a list, so nested map
  map(lam(x): map(lam(y): ((y &gt;= 97) and (y &lt;= 122)) is true end, string-to-code-points(x.name)) end, generate-input(3)) 
end

</pre>

<p>
Pyret has a built-in function for generating a list <a href="https://www.pyret.org/docs/latest/lists.html#%28part._lists_repeat%29">repeat()</a> which we will need to write ourselves since this assignment doesn't allow using built-ins outside of the higher order functions and sort() or sort-by() though I used some other list built-ins here and in the test cases since we already rewrote them in the Nile assignment. One way we could architect this is recursing on n, linking a list together. So num-random() gives us something resembling a random name, see this <a href="https://en.wikipedia.org/wiki/ASCII">article</a>, code points I guess could be between 97 and 122 or 'a' and 'z' though you could just leave this random and fuzzy test with all unicode code points since our sorters could hold foreign unicode names or math symbols or anything:
</p>

<pre class="example" id="org15511ab">
import lists as L

data Person:
  | person(name :: String, age :: Number)
end

fun generate-input(n :: Number) -&gt; List&lt;Person&gt;:
  doc:"Generate random n size list of person(name, age)"

  fun random-name(s :: Number, name-string :: String) -&gt; String:
    doc: "Generate a random string between ASCII 97 - 122 of length s"
    if s &lt; 1:
      name-string
    else:
      single = num-random(33) + 90
      if (single &gt;= 97) and (single &lt;= 122):
        random-name(s - 1, string-from-code-point(single) + name-string)
      else:
        random-name(s, name-string)
      end
    end
  where:
    string-length(random-name(5, "")) is 5
    string-length(random-name(1, "")) is 1
  end

  fun helper&lt;T&gt;(num :: Number, acc :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
    doc: "Consumes n, init acc and returns [list: person(name, age)] n times"    
    if num &lt; 1:
      acc
    else: 
      name-length = num-random(25) + 1
      helper(num - 1, link(person(random-name(name-length, ""), num-random(100) + 1), acc))
      # acc on first call is a placeholder here for empty
      # this will return ...link(item, link(item, orig-acc)) 
    end
  end

  # preconditions
  if n &lt; 1:
    raise("Input must be greater than 0")
  else:
    helper(n, empty)
  end
where:
  # confirm size
  L.length(generate-input(5)) is L.length([list: 1, 2, 3, 4, 5])
  map(lam(x :: Person): (string-length(x.name) &gt; 0) is true end, generate-input(2))  

  # make sure the age is within 1 - 100
  map(lam(x :: Person): x.age &gt; 0 is true end, generate-input(2))
  # confirm name is ASCII code points from 97 - 122 
  map(lam(x :: Person): map(lam(y): ((y &gt;= 97) and (y &lt;= 122)) is true end, string-to-code-points(x.name)) end, generate-input(2)) 

  # confirm input is &gt; 0
  generate-input(0) raises "Input must be greater than 0"
end
</pre>

<p>
Now we have what the assignment is looking for:
</p>

<pre class="example" id="orgbd566f7">
&gt;&gt;&gt; generate-input(2)
[list: person("vwqukq", 3), person("rljhrsijqcwyuglwjtnhc", 48)]
</pre>

<p>
Next is a sort validation function that consumes two sorted lists of type Person, and compares if they are both the same returning a boolean true or false. To compare if the first sorted input list is equal to the correct sorted list, we could map2 over both lists to do equality tests, then fold over the list map2 returns comparing each entry with 'true'. Note this is inefficient as a case statement can break on the first instance of false instead of continuing through the entire linear list: 
</p>

<pre class="example" id="org0cb3eb0">
fun is-valid(test-input :: List&lt;Person&gt;, correct-input :: List&lt;Person&gt;) -&gt; Boolean:
  doc: "Consumes l1 a sorted list and compares to l2 a correct-sorter() list"

  fun length-test(test-input-a :: List&lt;Person&gt;, correct-input-a :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if both lists are the same length"
    (L.length(test-input-a)) == (L.length(correct-input-a))
  end

  fun name-test(test-input-b :: List&lt;Person&gt;, correct-input-b :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if any names have been altered"
    correct-sorted-names = correct-sorter(test-input-b)
    names = map2(lam(n1 :: Person, n2 :: Person): (n1.name == n2.name) end, correct-sorted-names, correct-input-b)
    L.foldl(lam(a :: Boolean, b :: Boolean): a and b end, true, names)
  end

  fun age-sort-test(test-input-c :: List&lt;Person&gt;, correct-input-c :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "Test if sorted by age correctly"
    age-test = map2(lam(n3 :: Person, n4 :: Person): (n3.age == n4.age) end, test-input-c, correct-input-c)
    L.foldl(lam(c :: Boolean, d :: Boolean): c and d end, true, age-test)
  end

  fun age-and-name-sort-test(test-input-d :: List&lt;Person&gt;, correct-input-d :: List&lt;Person&gt;) -&gt; Boolean:
    doc: "See if the names and ages match, this will fail occasionally for qsort on duplicate ages"
    both-test = map2(lam(n5 :: Person, n6 :: Person): (n5.name == n6.name) and (n5.age == n6.age) end, test-input-d, correct-input-d)
    L.foldl(lam(e :: Boolean, f :: Boolean): e and f end, true, both-test)
  end

  # return the results
  if length-test(test-input, correct-input)
    and
    name-test(test-input, correct-input)
    and
    age-sort-test(test-input, correct-input)
    and
    age-and-name-sort-test(test-input, correct-input):
    true
  else:
    false  
  end
where:
  # some corner cases, omitted many tests
  is-valid(empty, empty) is true
  is-valid([list: person("a", 31)], empty) is false
  is-valid([list: person("", 31)], [list: person("a", 31)]) is false 
end
</pre>

<p>
Now we go about writing multiple buggy implementations of sorting algorithms and test these functions with oracle :: (List&lt;Person&gt; -&gt; List&lt;Person&gt;) -&gt; Boolean ie: oracle(insertion-sort)) or oracle(quick-sort):
</p>

<details id="org318d5a9">
<pre class="example" id="orgc52ab59">
fun combine(lt, p, gt):
  doc: "Used by quicksort"
  lt.append([list: p]).append(gt)
end

fun qsort(l :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  doc: "Quicksort from lectures"
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        qsort(r.filter(lam(n): n.age &lt; pivot.age end)),
        pivot,
        qsort(r.filter(lam(n): n.age &gt;= pivot.age end)))
  end
end

fun incorrect-qsort(l :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  doc: "Sabotaged quicksort"
  cases (List) l:
    | empty =&gt; empty
    | link(pivot, r) =&gt;
      combine(
        incorrect-qsort(r.filter(lam(n): n.age &lt; pivot.age end)),
        pivot,
        incorrect-qsort(r.filter(lam(n): n.age &gt; pivot.age end)))
  end
end

# empty case test
fun empty-sort(p :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;: 
  empty 
end

# deletes the names
fun name-screwed(w :: List&lt;Person&gt;) -&gt; List&lt;Person&gt;:
  correct = L.sort-by(w,
    lam(p1, p2): p1.age &lt; p2.age end,
    lam(p1, p2): p1.age == p2.age end)
  (map(lam(x): person("", x.age) end, correct))
end

fun oracle(f :: (List&lt;Person&gt; -&gt; List&lt;Person&gt;))-&gt; Boolean:
  doc: "Testing oracle for sorting lists of type Person"

  random-input = generate-input(num-random(30) + 5)
  is-valid(f(random-input), correct-sorter(random-input))
where:
  oracle(qsort) is true
  oracle(incorrect-qsort) is false
  oracle(name-screwed) is false
  oracle(empty-sort) is false
end
</pre>
</details>

<p>
These tests won't always pass, because sometimes incorrect-qsort() will produce the correct output, it's only on edge cases with duplicate ages that it won't pass our oracle test case. Quicksort will also sometimes produce a different sort sequence for multiple same ages or similar names with different ages that were correctly but differently sorted than the sequence correct-sorter() uses.   
</p>
</div>

<div id="outline-container-Check%20your%20work%20against%20the%20official%20solution" class="outline-3">
<h3 id="Check%20your%20work%20against%20the%20official%20solution">Check your work against the official solution</h3>
<div class="outline-text-3" id="text-Check%20your%20work%20against%20the%20official%20solution">
<p>
Write your solution first, then read this <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wnk-use-rel-prob-pbt/">pdf</a>. He writes about how this course encourages <a href="http://cs.brown.edu/courses/cs195y/2020/pages/pdf/01.24-propertiesandoracles.pdf">property-based testing</a> which is a way to test properties instead of values and there is a thorough writeup about this sortacle assignment what they graded for and exactly what would fail their tests. 
</p>

<p>
We find out they didn't really care about the generator only that it is a good drill exercise, they primarily tested is-valid extracting only that function to test. They broke the testing down into specific properties is-valid should have and exactly how they implemented their own tests for these properties. 
</p>

<p>
My implementation passed most of their grading tests, as my tests checked if outputs were not the same as inputs (missing names/ages/changed sizes) and although my tests caught whenever correct-sorter hit a corner case like quicksort where duplicate ages could have different order if sorted by age, I didn't handle this false is-valid with additional checks and since these sorts were still valid my implementation would be useless for automated testing. I also sanitized generate-input but did not check for out of bounds ages in is-valid.  
</p>

<p>
The grading tests for oracle assignment (actually, all the assignments) are also in the same paper, don't read it until after you try your own implementation to see if you are picking up these property-based testing techniques.  
</p>
</div>
</div>

<div id="outline-container-Logic%20for%20Systems" class="outline-3">
<h3 id="Logic%20for%20Systems">Logic for Systems</h3>
<div class="outline-text-3" id="text-Logic%20for%20Systems">
<p>
The techniques they used in the paper are taught in their <i>Logic for Systems</i> class which I partially archived with some recorded lectures if you're interested in this kind of logical thinking about programs. We will do something similar later, reasoning about the specifications of programs and their behavior. 
</p>

<pre class="example" id="orgbf6ea31">
Archive of 195y if you're interested before recorded lectures disappear
magnet:?xt=urn:btih:3187a9951b43b85771a975653680a4a8d9faf61d&amp;dn=195y
</pre>
</div>
</div>
</div>


<div id="outline-container-Assignment%204%3A%20Data%20Scripting" class="outline-2">
<h2 id="Assignment%204%3A%20Data%20Scripting">Assignment 4: Data Scripting</h2>
<div class="outline-text-2" id="text-Assignment%204%3A%20Data%20Scripting">
<p>
This assignment is yet more <a href="http://cs.brown.edu/courses/csci0190/2018/datascrdatascr.html">practice</a> that mirrors what a typical developer would have to do unravelling data out of nested structures and writing quick basic tasks.
</p>
</div>

<div id="outline-container-is-palindrome%28%29%20and%20sum-largest%28%29" class="outline-4">
<h4 id="is-palindrome%28%29%20and%20sum-largest%28%29">is-palindrome() and sum-largest()</h4>
<div class="outline-text-4" id="text-is-palindrome%28%29%20and%20sum-largest%28%29">
<p>
Straight forward to figure out using map/map2/fold.. 
</p>
</div>
</div>

<div id="outline-container-adding-machine%28%29" class="outline-4">
<h4 id="adding-machine%28%29">adding-machine()</h4>
<div class="outline-text-4" id="text-adding-machine%28%29">
<p>
Notice two consecutive 0's in the test case which will screw up your list/empty cases if you're linking on occurrences of 0 unless you filter the returned acculumator.
</p>
</div>
</div>

<div id="outline-container-bmi-report%28%29" class="outline-4">
<h4 id="bmi-report%28%29">bmi-report()</h4>
<div class="outline-text-4" id="text-bmi-report%28%29">
<p>
Template is:
</p>
<pre class="example" id="org255520b">
data PHR:
  | phr(name :: String,
      height :: Number,
      weight :: Number,
      heart-rate :: Number)
end

data Report:
  | bmi-summary(under :: List&lt;String&gt;,
      healthy :: List&lt;String&gt;,
      over :: List&lt;String&gt;,
      obese :: List&lt;String&gt;)
end

fun bmi-report(phrs :: List&lt;PHR&gt;) -&gt; Report:
  ...
where:
  bmi-report([list: phr("eugene", 2, 60, 77),
      phr("matty", 1.55, 58.17, 56 ),
      phr("ray", 1.8, 55, 84),
      phr("mike", 1.5, 100, 64)]) is 
  bmi-summary([list: "eugene", "ray"], # under
    [list: "matty"],         # healthy
    [list: ],                # over
    [list: "mike"]           # obese
    )
end
</pre>

<p>
My solution was to write a helper function bmi(p :: PHR) -&gt; Number and then filter each list for under, healthy, over, obese. Return bmi-summary by mapping over those filtered lists for lam(x): x.name, try adding more test cases like the empty case, or multiple same names. Assignment claims we can assume no entry will be zero so we don't need a test case for division by zero.
</p>
</div>
</div>

<div id="outline-container-data-smooth%28%29" class="outline-4">
<h4 id="data-smooth%28%29">data-smooth()</h4>
<div class="outline-text-4" id="text-data-smooth%28%29">
<p>
You could want tests for empty, one element, two elements, and the given assignment example:
</p>

<pre class="example" id="orgadac88b">
fun data-smooth(phrs :: List&lt;PHR&gt;) -&gt; List&lt;Number&gt;:
  doc: "Smooth heart rate data"
...
where:
  # given example from assignment writeup
  data-smooth([list: phr("eugene", 2, 60, 95),
      phr("matty", 1.55, 58.17, 102),
      phr("ray", 1.8, 55, 98),
      phr("mike", 1.5, 100, 88), phr("a", 2, 2, 105)]) is [list: 95, 295/3, 96, 97, 105]

  # empty test
  data-smooth(empty) is empty

  # one element test
  data-smooth([list: phr("spock", 3, 2, 1)]) is [list: 1]

  # two element test
  data-smooth([list: phr("spock2", 1, 2, 90), phr("spock3", 3, 4, 91)]) is [list: 90, 91]
end
</pre>
</div>
</div>

<div id="outline-container-frequent-words%28%29" class="outline-4">
<h4 id="frequent-words%28%29">frequent-words()</h4>
<div class="outline-text-4" id="text-frequent-words%28%29">
<p>
I wrote this template:
</p>

<pre class="example" id="org75a7085">
# optional
data Freq:
  | frequency(word :: String, count :: Number)
end

fun frequent-words(words :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
 ...
where:
  frequent-words([list: "silver", "james", "james", "silver",
      "howlett", "silver", "loganne", "james", "loganne"])
    is  [list: "james", "silver", "loganne"]
  frequent-words([list: "a", "a", "a", "a", "b", "b", "c"]) is [list: "a", "b"]
  # corner case, all words are only 1 frequency so return sorted
  frequent-words([list: "james", "so"]) is [list: "so", "james"  ]
  frequent-words(empty) is empty
end
</pre>

<p>
The assignment wants a list returned of words, in descending order of freq count, sorted by smallest string length if there's a tie. If the highest frequency count is greater than 1, then you return those words otherwise return the list sorted if there are no freq greater than 1 is how I interpret the assignment. 
</p>
</div>
</div>

<div id="outline-container-daily-max-for-month%28%29" class="outline-4">
<h4 id="daily-max-for-month%28%29">daily-max-for-month()</h4>
<div class="outline-text-4" id="text-daily-max-for-month%28%29">
<p>
We're asked to take [list: 20151004, 150, 200, 175, 20151005, 0.002, 0.03, 20151007, 130, 0.54, 20151101, 78] and turn it into a daily maximum [list: max-hz(20151004, 200), max-hz(20151005, 0.03), max-hz(20151007, 130)] if the searched for month is October. Our template:
</p>

<pre class="example" id="org7bcbbe5">
data Report:
  | max-hz(date :: Number, max-reading :: Number)
end

fun daily-max-for-month(sensor-data :: List&lt;Number&gt;, month :: Number) -&gt; List&lt;Report&gt;:
  ...
where:
  input = [list: 20151004, 150, 200, 175, 20151005, 0.002, 0.03, 20151007, 130, 0.54, 20151101, 78]
  daily-max-for-month(input, 10) is [list: max-hz(20151004, 200), max-hz(20151005, 0.03), max-hz(20151007, 130)]
end
</pre>

<p>
I completed this with 2 functions maxx(), and a helper(). I filtered sensor-data for the month desired to get a distinct list of all dates of that month [list: 20151004, 20151005, 20151007] since if you multiply month by 100, and add 20150000 you get the desired month. Then I called helper(distinct-list, sensor-data) which tested if f was a member of my distinct month list. If so I called maxx to find the highest count that day: link(max-hz(f, maxx(r), helper(distinct-list, r))). 
</p>
</div>
</div>
</div>


<div id="outline-container-Lecture%207%20Trees" class="outline-2">
<h2 id="Lecture%207%20Trees">Lecture 7 Trees</h2>
<div class="outline-text-2" id="text-Lecture%207%20Trees">
<p>
We're watchin Fri9/21/18 lecture on 2D tree shaped data w/guest lecturer <a href="http://cs.brown.edu/~tbn/publications/">Tim Nelson</a> who is an expert in formal methods such as proving correct a network security policy as an example or formally verifying software models something we will be doing in the courses after this one. An interesting paper from his page authored with Prof K you should read is <i>The Human in Formal Methods</i>. In it they write about porting the method of example writing we've been doing to this domain. A common learning mistake that students make is talked about, in that they write programs before they have understood the problem, as a result they 'solve' the wrong problem, which misdirected from the learning goals. If you read the paper linked in the first DocDiff assignment you already know this.
</p>

<p>
The mutual recursive datatypes, to understand them write out your own tree:
</p>
<pre class="example" id="org338c8ba">
       a 
      /  \   
    b    none     
   /  \
  c    none
   \ 
    none

a has child b and none
b has child c and none
c has none
</pre>

<ul class="org-ul">
<li>start with a:</li>
<li>person("a", No-children)</li>
<li>add in b:</li>
<li>person("a", <b>child(person("b", No-children)</b>, No-children))</li>
<li>add in c:</li>
<li>e2 = person("a", child(person("b", <b>child(person("c", No-children)</b>, No-children)), No-children))</li>
</ul>
</div>


<div id="outline-container-PAPL%20Chapter%2013%20%2FRecursive%20datatypes%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2013%20%2FRecursive%20datatypes%2F">PAPL Chapter 13 <i>Recursive datatypes</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2013%20%2FRecursive%20datatypes%2F">
<p>
The recursive data definitions that we saw in Lecture 7, and they hand step through a recursive function. Seems like this should be in chapter 1. The design recipe template from HtDP book for recursive data definitions is also shown now you have the full design recipe for future assignments. 
</p>
</div>
</div>
</div>

<div id="outline-container-Lecture%208%20Sets" class="outline-2">
<h2 id="Lecture%208%20Sets">Lecture 8 Sets</h2>
<div class="outline-text-2" id="text-Lecture%208%20Sets">
<p>
We're watching Mon9/24/18 lecture on sets. This is a design lecture, given something that has no notion of order, how do you design it's data structure representation.
</p>

<p>
When he shortens insert() to equal link, try it in the pyret repl. The end of this lecture discussing the big-O complexity of both representations he points out the inefficient representation is better depending on what you care about, like appending a log you often don't look at. 
</p>
</div>

<div id="outline-container-PAPL%20Chapter%2012%20%26%2018.1%20%2FSets%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2012%20%26%2018.1%20%2FSets%2F">PAPL Chapter 12 &amp; 18.1 <i>Sets</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2012%20%26%2018.1%20%2FSets%2F">
<p>
We haven't covered 18.2 yet so just reading 18.1. The lecture covered everything in these 2 chapters and goes into further detail about choosing how to build a representation.  
</p>

<p>
There's a link to the <a href="https://papl.cs.brown.edu/2019/glossary.html">glossary</a>, interesting definitions in there such as links to a paper on coalgebras/coinduction. In the size() recurrence, remember the chapter <i>Predicting Growth</i> where common recurrences are listed such as T(k) = T(k - 1) + k is \([k \rightarrow k^2]\) because it's closed form solution is: \(\frac{k^2 + k}{2}\) hence T(d) = d + (d - 1) is also \([d \rightarrow d^2]\).
</p>
</div>
</div>

<div id="outline-container-PAPL%20Chapter%2015%20%2FOracles%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2015%20%2FOracles%2F">PAPL Chapter 15 <i>Oracles</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2015%20%2FOracles%2F">
<p>
This is short unfinished <a href="https://papl.cs.brown.edu/2020/testing.html">chapter</a> on testing. In testing blocks we have some new binary and unary test <a href="https://www.pyret.org/docs/latest/testing.html">operators</a> we can use like <i>expr1 is%(function) expr2</i> or <i>expr1 satisfies (function)</i>. Pyret documentation has examples, is%(function) exists so you can test your very optimized new function against a slower proven correct version and ensure the outputs are the same. 
</p>
</div>
</div>
</div>

<div id="outline-container-Assignment%205%3A%20Oracle" class="outline-2">
<h2 id="Assignment%205%3A%20Oracle">Assignment 5: Oracle</h2>
<div class="outline-text-2" id="text-Assignment%205%3A%20Oracle">
<p>
Let's build a testing <a href="http://cs.brown.edu/courses/csci0190/2019/oracleoracle.html">oracle</a>. There's a starter <a href="https://code.pyret.org/editor#share=1ZCe4jQepT5vars3-1dK8jBPVhAllLBoq&amp;v=7aff971">template</a> we need to access the function they give us matchmaker() and is-hire() 
</p>

<details id="orgbbe4998">
<pre class="example" id="org6648c50">
# CSCI0190 (Fall 2018)
provide *
provide-types *

import shared-gdrive("oracle-support.arr",
  "11JjbUnU58ZJCXSphUEyIODD1YaDLAPLm") as O

##### PUT IMPORTS BELOW HERE ############


##### PUT IMPORTS ABOVE HERE ############

type Hire = O.Hire
hire = O.hire
is-hire = O.is-hire
matchmaker = O.matchmaker

# DO NOT CHANGE ANYTHING ABOVE THIS LINE

fun generate-input(num :: Number) -&gt; List&lt;List&lt;Number&gt;&gt;:
  doc: 
  ```
  generates a list of candidates or companies for a group of size num
  ```
  empty
where:
  generate-input(0) is empty
end

fun is-valid(
    companies :: List&lt;List&lt;Number&gt;&gt;,
    candidates :: List&lt;List&lt;Number&gt;&gt;,
    hires :: Set&lt;Hire&gt;)
  -&gt; Boolean:
  doc: 
  ```
  Tells if the set of hires is a good match for the given
  company and candidate preferences.
  ```
  true
where:
  is-valid(empty, empty, empty-set) is true
end

fun oracle(a-matchmaker :: (List&lt;List&lt;Number&gt;&gt;, List&lt;List&lt;Number&gt;&gt; 
      -&gt; Set&lt;Hire&gt;))
  -&gt; Boolean:
  doc: 
  ```
  Takes a purported matchmaking algorithm as input and outputs whether or
  not it always returns the correct response
  ```
  true
where:
  oracle(matchmaker) is true
end
</pre>
</details>

<p>
Run the template then try to give matchmaker some inputs to see what it does:
</p>

<pre class="example" id="org0d52e3e">
companies =  [list: [list: 1, 0, 2], [list: 0, 2, 1], [list: 0, 2, 1]]
candidates = [list: [list: 1, 0, 2], [list: 1, 2, 0], [list: 0, 1, 2]]
# Note matchmaker writeup: it is 0 to n-1 indexed, so 3 lists means 0 - 2 

matchmaker(companies, candidates)
&gt;&gt;[list-set: hire(2, 1), hire(1, 0), hire(0, 2)]
</pre>

<p>
First Let's understand the matching algorithm, we don't have to write one ourselves but we have to know how it works in order to test all the false matchmaker algorithms in our oracle. Let's look at the actual <a href="http://www.eecs.harvard.edu/cs286r/courses/fall09/papers/galeshapley.pdf">paper</a>. Scroll down to Theorem 1: <i>There always exists a stable set of marriages</i> and look at the proof for the algorithm:
</p>

<ul class="org-ul">
<li>First round:</li>
<li>Companies all select their first preferred candidate</li>
<li>Candidates accept provisionally, if a more preferred offer is presented in next rounds they will reject this one
<ul class="org-ul">
<li>Rejected companies are put into a pool</li>
</ul></li>
<li>Second round:</li>
<li>Companies in the pool with no matching then all select their second preferred candidate</li>
<li>Candidates accept or reject upon preferences</li>
<li>X rounds:</li>
<li>Repeat, noting that no company can offer more than once to a candidate</li>
</ul>

<p>
The 2019 assignment writeup contains a few hints, such as 'be cautious about using the provided matchmaker function in your oracle as this assumes that there is only one right answer to a given instance of the stable hiring problem'. I translate this to mean there could be many permutations of the stable-hiring problem which are still correct, however the Gale-Shipley algorithm produces the exact same matching everytime if the company is making offers, and candidates rejecting. What if the roles are reversed, if it is candidate making offers and company rejecting, is the matching then different? We have 2 inputs into matchmaker but it doesn't say which one is actually making the offers and which input is rejecting. We should try altering the inputs and see what happens: 
</p>

<pre class="example" id="orge416247">
companies =  [list: [list: 1, 0, 2], [list: 0, 2, 1], [list: 0, 2, 1]]
candidates = [list: [list: 1, 0, 2], [list: 1, 2, 0], [list: 0, 1, 2]]

&gt;&gt;matchmaker(candidates, companies)
[list-set: hire(2,2), hire(1,0), hire(0,1)]

&gt;&gt;matchmaker(companies, candidates)
[list-set: hire(2,1), hire(1,0), hire(0,2)]
</pre>

<p>
They're different, so there is indeed more than one solution to the problem depending on if the bias is towards candidates or companies. So how are we going to test the property for any stable matching. I find an old book, entirely on the Stable Marriage problem <a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15251-f10/Site/Materials/Lectures/Lecture21/lecture21.pdf">here</a> and on page 8 <i>Stability Checking</i> we are given a stability checking algorithm and on page 7 this is more clearly defined: For each company C, look at their preferences and check that each candidate they prefer is not matched to somebody else if candidate also prefers company C.
</p>

<ul class="org-ul">
<li>Some tests to implement:
<ul class="org-ul">
<li>check the hire pairs are bounded with the input
<ul class="org-ul">
<li>no hire(7,1) if input is only 3 companies</li>
</ul></li>
<li>check n companies and n candidates are in n pairs</li>
<li>check for duplicate matchings</li>
<li>check they are stable as per the algorithm in that book</li>
</ul></li>
</ul>

<p>
This was my good enough generate-input function for test inputs &lt; num = 25, more than that and needs optimization, like using a dictionary datastructure or keep a sorted accumulator to check for dupes. 
</p>

<details id="orgb59e467">
<pre class="example" id="orgf959df9">
fun generate-input(num :: Number) -&gt; List&lt;List&lt;Number&gt;&gt;:
  doc: 'generates a list of candidates or companies for a group of size num'
  fun test-for-dupes(input :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
    doc: 'Checks for duplicate prefs in the list'
    distinct-input = L.distinct(input)
    if (L.length(distinct-input) &lt; num):
      test-for-dupes(distinct-input
          + map(lam(x): num-random(num) end, repeat(num - distinct-input.length(), 0)))
    else:
      input
    end
  end

  fun create-list(n :: Number) -&gt; List&lt;Number&gt;:
    doc: 'Assembles list of distinct prefs'
    randomized = map(lam(x): num-random(n) end, repeat(n, 1))
    test-for-dupes(randomized)
  end

  if (num &lt;= 0):
    # If empty, return empty
    empty
  else if num == 1: 
    # If n, return n - 1 
    [list: [list: 0]]
  else:
    # repeat gives a skeleton list to map over of size num
    map(lam(x): create-list(num) end, repeat(num, 1)) 
  end
where:
  generate-input(0) is empty
  generate-input(-1) is empty
  generate-input(1) is [list: [list: 0]]
  L.length(generate-input(3)) is 3
  # omitted a bunch of tests here
end
</pre>
</details>
</div>

<div id="outline-container-Check%20your%20solution" class="outline-3">
<h3 id="Check%20your%20solution">Check your solution</h3>
<div class="outline-text-3" id="text-Check%20your%20solution">
<p>
The same <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wnk-use-rel-prob-pbt/">paper</a> we read for Sortacle assignment there is a writeup for this one too. Once again they didn't really care that much about the input generation functions. Checking my own work they cared that is-valid tested for stability, uniqueness and completeness which my tests all covered mainly because I found that old book on the stable matchmaking problem that handed me a stability testing algorithm and from years of reading hacky software I just expected disaster so tested for dupes and incompleteness. 
</p>

<p>
How they came up with these tests is a good read, they used Alloy taught in cs195y (also the book <i>Software Foundations</i> by Jackson) to produce a model where all three properties were satisfied, then had Alloy produce unstable matchings while preserving the other two properties unique and complete. 
</p>
</div>
</div>
</div>

<div id="outline-container-Lecture%209%20Logarithmic%20Growth" class="outline-2">
<h2 id="Lecture%209%20Logarithmic%20Growth">Lecture 9 Logarithmic Growth</h2>
<div class="outline-text-2" id="text-Lecture%209%20Logarithmic%20Growth">
<p>
We're watching lecture Wed/9/26/18. This is a light lecture just explaining the intuition behind logarithmic complexity to set up balanced binary search trees. At 7:10 he explains logarithms: "A (base-10) logarithm of a number is essentially how many digits a number has. That's it". He then explains in terms of virtual machine costs, if you have a logarithmic algorithm and there is a million new runs of that algorithm you are only paying 6x the cost.    
</p>
</div>
</div>

<div id="outline-container-Lecture%2010%20Balanced%20Binary%20Search%20Trees" class="outline-2">
<h2 id="Lecture%2010%20Balanced%20Binary%20Search%20Trees">Lecture 10 Balanced Binary Search Trees</h2>
<div class="outline-text-2" id="text-Lecture%2010%20Balanced%20Binary%20Search%20Trees">
<p>
This is lecture Fri/9/28/18. We discover the entire last lecture was just trolling and would not give us logarithmic time in terms of successfully being able to throw away half the data because the tree isn't balanced. This whole lecture is understanding how you can balance a tree. 
</p>
</div>

<div id="outline-container-PAPL%20Chapter%2018.2%20%2FTrees%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2018.2%20%2FTrees%2F">PAPL Chapter 18.2 <i>Trees</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2018.2%20%2FTrees%2F">
<p>
All of <a href="https://papl.cs.brown.edu/2020/set-representations.html#%28part._sets-grow-trees%29">this</a> was covered in the lecture, including most of the exercises. There's an interesting writeup about how hashing functions work. 
</p>
</div>
</div>

<div id="outline-container-Lab%3A%20Tree%20Traversal" class="outline-3">
<h3 id="Lab%3A%20Tree%20Traversal">Lab: Tree Traversal</h3>
<div class="outline-text-3" id="text-Lab%3A%20Tree%20Traversal">
<p>
Let's try the CS19 lab for <a href="https://zacharyespiritu.com/documents/teaching/csci0190/iterating-over-trees-lab.pdf">trees</a>. The first part is just thought exercises then the lab offers us stencil code for the BT tree lab sections:
</p>

<pre class="example" id="orgc04394f">
#  _____                _                                      _ 
# |_   _| __ ___  ___  | |_ _ __ __ ___   _____ _ __ ___  __ _| |
#   | || '__/ _ \/ _ \ | __| '__/ _` \ \ / / _ \ '__/ __|/ _` | |
#   | || | |  __/  __/ | |_| | | (_| |\ V /  __/ |  \__ \ (_| | |
#   |_||_|  \___|\___|  \__|_|  \__,_| \_/ \___|_|  |___/\__,_|_|

data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

fun btree-in-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via an in-order traversal"
  ...
where:
  nothing
end

fun btree-pre-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via a pre-order traversal"
  ...
where:
  nothing
end

fun btree-post-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via a post-order traversal"
  ...
where:
  nothing
end
</pre>

<p>
First make a tree, run it, and type 'a-tree' into pyret interpreter and click the output to see the right and left branches, or a-tree.left or a-tree.right
</p>

<pre class="example" id="org519fb5a">
a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

&gt;&gt; a-tree.left
node(4, node(3, mt, mt), mt)

&gt;&gt; a-tree.right
node(6, node(7, mt, mt), node(8, mt, mt))

&gt;&gt; a-tree.value
5
</pre>

<p>
The lab wants us to write various traversals, here's what I wrote for btree-in-order which is basically the other two orders as well, just rearrange helper(l) + root + helper(r):
</p>


<pre class="example" id="org91da265">
data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

# degenerate tree from PAPL chapter 17.2.2
b-tree = node(1, mt,
  node(2, mt,
    node(3, mt,
      node(4, mt, mt))))

fun btree-in-order&lt;A&gt;(tree :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
  doc: "Returns the elements of tree in a list via an in-order traversal"

  fun helper(n :: BTree&lt;A&gt;) -&gt; List&lt;A&gt;:
    cases (BTree) n:
      | mt =&gt; empty
      | node(v, l, r) =&gt;
        link(v, helper(l) + helper(r)) 
    end
  end

  cases (BTree) tree:
    | mt =&gt; empty
    | node(v, l, r) =&gt;
      helper(l) + link(v, empty) + helper(r)
  end
where:
  btree-in-order(a-tree) is [list: 4, 3, 5, 6, 7, 8]
  btree-in-order(b-tree) is [list: 1, 2, 3, 4]
end
</pre>

<p>
Another lab where we rewrite map/filter/fold. Below when you see Prof K's lecture on knowledge transfer you'll understand why he makes us do this over and over. This is my first attempt at map, I wrote it like he writes software on the board in class thinking through the data definition:
</p>

<pre class="example" id="org62a0ed8">
data BTree&lt;T&gt;:
  | mt
  | node(value :: T, left :: BTree&lt;T&gt;, right :: BTree&lt;T&gt;)
end

a-tree =
  node(5,
    node(4, 
      node(3, mt, mt), mt),
    node(6, node(7, mt, mt), node(8, mt, mt)))

# degenerate tree from PAPL chapter 17.2.2
b-tree = node(1, mt,
  node(2, mt,
    node(3, mt,
      node(4, mt, mt))))

fun btree-map&lt;A, B&gt;(f :: (A -&gt; B), tree :: BTree&lt;A&gt;) -&gt; BTree&lt;B&gt;:
  doc: "Recursively applies f to the value of every node contained in tree"

  cases (BTree) tree:
    | mt =&gt; mt
    | node(v, l, r) =&gt;
      node(f(v), btree-map(f, l), btree-map(f, r))
  end
where:
  btree-map(lam(x): x + 1 end, a-tree) is node(6, node(5, node(4, mt, mt), mt), 
    node(7, node(8, mt, mt), node(9, mt, mt)))
  btree-map(lam(x): x + 1 end, b-tree) is node(2, mt, node(3, mt, node(4, mt, node(5, mt, mt))))
end

&gt;&gt;btree-map(lam(x): x * x end, a-tree)
node(25, node(16, node(9, mt, mt), mt), node(36, node(49, mt, mt), node(64, mt, mt)))

</pre>

<p>
Note that btree-fold the lab wants you to convert the tree to a list, apply f to every element and produce a value just like regular fold does with a warning about complete testing, meaning every function of regular fold should be replicated here.  
</p>
</div>
</div>
</div>

<div id="outline-container-Assignment%206%3A%20Filesystem" class="outline-2">
<h2 id="Assignment%206%3A%20Filesystem">Assignment 6: Filesystem</h2>
<div class="outline-text-2" id="text-Assignment%206%3A%20Filesystem">
<p>
I interpret the <a href="https://cs.brown.edu/courses/cs019/2018/filesystemfilesystem.html">assignment</a> to mean this directory tree/model:
</p>

<pre class="example" id="orgec42046">
# this is missing from my template:
type Path = List&lt;String&gt;

# you can omit size field, so c = file("name", "text") and c.size will return size 4 of the content field 'text'.  
filesystem = (dir("TS", [list:
        dir("Text", empty, [list: file("part1", 99, "content"), file("part2", 52, "content"), file("part3", 17, "content")]),   
        dir("Libs", [list: 
            dir("Code", empty, [list: file("hang", 8, "content"), file("draw", 2, "content")]), 
            dir("Docs", empty, [list: file("read!", 19, "content")])], empty)],
      [list: file("read!", 10, "content")]))
</pre>

<p>
Recall that Pyret allows you to write methods for datatype, here's an example for du-dir() where I wrote a .size() method you can call on any directory:
</p>

<pre class="example" id="org24196db">
provide *
provide-types *

data File:
  | file(name :: String, size :: Number, content :: String)
end

data Dir:
  | dir(name :: String, ds :: List&lt;Dir&gt;, fs :: List&lt;File&gt;) with:
    method size(self :: Dir) -&gt; Number:
      doc: "Returns combined file size, file count, and sub directory count of a Dir"
      size(self)
    end
end

fun size(d :: Dir) -&gt; Number:
  doc: "Method .size()"

  fun fsize(fd :: Dir) -&gt; Number:
    doc: "Returns file size, and number of files in a Dir"
    fd.fs.foldl(lam(f :: File, acc :: Number): 1 + f.size + acc end, 0)
  end

  fsize(d)
    + map(lam(x :: Dir): 1 + size(x) end, d.ds).foldl(lam(elt, acc): elt + acc end, 0)
end
check:
  a = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 1, "content")])], empty)

  b = dir("Libs", [list: 
      dir("Code", empty, [list: file("hang", 1, "content"), file("draw", 1, "content")]), 
      dir("Docs", empty, [list: file("read!", 1, "content")])], empty)

  c = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 1, "content"), file("part2", 1, "content"), file("part3", 1, "content")]),   
      dir("Libs", [list: 
          dir("Code", empty, [list: file("hang", 1, "content"), file("draw", 2, "content")]), 
          dir("Docs", empty, [list: file("read!", 1, "content")])], empty)],
    [list: file("read!", 1, "content")])

  d = dir("TS", [list:
      dir("Text", empty, [list: file("part1", 99, "content"), file("part2", 52, "content"), file("part3", 17, "content")]),   
      dir("Libs", [list: 
          dir("Code", empty, [list: file("hang", 8, "content"), file("draw", 2, "content")]), 
          dir("Docs", empty, [list: file("read!", 19, "content")])], empty)],
    [list: file("read!", 10, "content")])

  e = dir("TS", empty, [list: file("", 1, "")])

  a.size() is 3
  b.size() is 8
  c.size() is 19
  d.size() is 218
  e.size() is 2
end
</pre>

<p>
This is all in the Pyret documentation, and I looked at the Pyret source on github to see how to chain multiple methods:
</p>

<pre class="example" id="org2a209b5">
data Dir:
  | dir(name :: String, ds :: List&lt;Dir&gt;, fs :: List&lt;File&gt;) with:
    method size(self :: Dir) -&gt; Number:
      doc: "Returns the size of all sub directories"
      size(self)
    end,
    method path(self :: Dir, s :: String) -&gt; List&lt;Path&gt;:
      doc: "Takes a Dir, and a search string, returns the path"
      path(self, s)
    end
end
</pre>

<p>
The path method there's numerous ways you could architect this to be better. Advice: I do these exercises on a phone whenever I have spare time (commuting, lunch break, randomly get an idea somewhere) and often repeated the same annoying mistake using [list: ] instead of 'empty' which seems to break everything in Pyret test cases.
</p>
</div>
</div>

<div id="outline-container-Assignment%207%3A%20Updater" class="outline-2">
<h2 id="Assignment%207%3A%20Updater">Assignment 7: Updater</h2>
<div class="outline-text-2" id="text-Assignment%207%3A%20Updater">
<p>
Reading the <a href="http://cs.brown.edu/courses/csci0190/2018/updaterupdater.html">assignment</a> for updater, this is a functional updater where we are trying to design left, right, up, down and update in constant time, meaning we can just wipe out a subtree replacing it with mt and filter the results. Try and make something that works first to understand it then rewrite it to be more efficient. Before you click on <a href="https://code.pyret.org/editor#share=1wOojo-47DzLH4dKzPmZBD3IUkd8Z3DQn&amp;v=7aff971">implementation</a> in CPO make a test tree and play around with it:
</p>

<pre class="example" id="orgf83ef5b">
import lists as L

data Tree&lt;A&gt;:
  | mt
  | node(value :: A, children :: List&lt;Tree&gt;)
end

# test tree:
#        1
#       / \
#      2   5
#     / \   \
#    4   3   6 
#         \
#         3.5

test-tree = 
  node(1, [list:
      node(2, 
        [list: node(4, empty), node(3, [list: node(3.5, empty)])]),
      node(5, 
        [list: node(6, empty)])])

# left side
test-tree.children.get(0)

# right side
test-tree.children.get(1)

# get node 3.5
test-tree.children.get(0).children.get(1).children.get(0)

fun get-nodes(tree, l):
  L.fold(lam(t, x): t.children.get(x) end, tree, l)
where:
  get-nodes(test-tree, [list: 0, 1,0]) is node(3.5, empty)
  get-nodes(test-tree, [list: 0, 0]) is node(4, empty)
  get-nodes(test-tree, [list: 1, 0]) is node(6, empty)
  get-nodes(test-tree, [list: 1]) is node(5, [list: node(6, empty)])

  # map n produces [list: 0, 1]
  get-nodes(test-tree, map_n(lam(n, _): n end, 0, test-tree.children)) 
    is node(3, [list: node(3.5, empty)])
end
</pre>

<p>
The easiest way to start, is design a cursor datatype of cursor-above, index, cursor-point where the index is 0 or 1 representing the position in the list of the thing you are pointing at for .get/.set methods and for detecting invalid movement. If you are at index 0, you can move right but you can't move left (binary tree datatype, only two branches), so move up and measure the length of the children list to see if it's &gt; 0 then .children.get(1) and you've moved right.  
</p>

<p>
After I tried that design for fun I made a crazy hack where I tracked the position of the cursor with a list then folded over it with tree.children.get(x). For movement from [list: 0, 1, 0] going right, I chopped the last element and measured then length of it's parent [list: 0, 1].children to see if it was a valid movement. I even changed the find-cursor function to be a pile of .get()s mapping over branches with map n which returns an index where predicate(x) is true, this made the requirement of depth-first searching simple since the encoded .get()s are easy to interpret in [list: 0, 1] format, if index 1 is 0 it's in the first branch, if index 2 is also 0 then it's the most left branch and higher than [list: 0, 0, 0].    
</p>

<p>
get-node-val returns type <a href="https://www.pyret.org/docs/latest/option.html">option</a> (this is also in PAPL under Chapter 12/Sets) an option will wrap the response in some(v) which you extract with some.value or read the documentation for some(a) =&gt; a syntax. Including an underscore in cases means you don't plan on using that field in the =&gt; cases. 
</p>

<pre class="example" id="org37fc724">
fun get-node-val&lt;A&gt;(cur :: Cursor&lt;A&gt;) -&gt; Option&lt;A&gt;: 
  cases(Tree) cur.point:
    | node(v, _) =&gt; some(v) 
    | mt =&gt; none
  end
where:
  get-node-val(find-cursor(test-tree, lam(x): x == 3 end)).value is 3 
  get-node-val(cursor(mt, empty, mt)) is none
end
</pre>
</div>
</div>


<div id="outline-container-Lecture%2011%20Streams" class="outline-2">
<h2 id="Lecture%2011%20Streams">Lecture 11 Streams</h2>
<div class="outline-text-2" id="text-Lecture%2011%20Streams">
<p>
Watching lecture titled Mon/10/01/18. In the examples of ones, everytime you invoke 'ones' you get lzlink(1, &lt;thunk&gt;) which is one, plus a way to get more ones if called again. We're asked to write our own map, you could also try it with cases:
</p>

<pre class="example" id="org5200b3e">
fun maps&lt;A, B&gt;(f :: (A -&gt; B), s :: Lz&lt;A&gt;) -&gt; Lz&lt;B&gt;:
  cases (Lz&lt;A&gt;) s:
    | lzlink(e, r) =&gt; lzlink(f(e), {(): maps(f, rst(s))}) 
  end
end

fun maps2&lt;A, B, C&gt;(f :: (A, B -&gt; C), s1 :: Lz&lt;A&gt;, s2 :: Lz&lt;B&gt;) -&gt; Lz&lt;C&gt;:
  cases (Lz&lt;A&gt;) s1:
    | lzlink(e, r) =&gt; 
      cases (Lz&lt;B&gt;) s2:
        | lzlink(ee, rr) =&gt; lzlink(f(e, ee), {(): maps2(f, rst(s1), rst(s2))})
      end
  end
end

&gt;&gt;s2 = maps(lam(x): x - 1 end, nats)
&gt;&gt;take(s2, 5)
[list: -1, 0, 1, 2, 3]

&gt;&gt;s3 = maps2(lam(x, y): x + y end, nats, nats)
&gt;&gt;take(s3, 5)
[list: 0, 2, 4, 6, 8]
</pre>

<p>
The type variables annotation he used maps&lt;A,B,C&gt;(f :: (A -&gt; B),..)-&gt; Stream&lt;C&gt;: is in the streams chapter of the text and in <a href="https://papl.cs.brown.edu/2020/para-poly.html">Chapter 27</a>. 
</p>
</div>

<div id="outline-container-PAPL%20Chapter%2016%20%2FFunctions%20as%20Data%2F" class="outline-3">
<h3 id="PAPL%20Chapter%2016%20%2FFunctions%20as%20Data%2F">PAPL Chapter 16 <i>Functions as Data</i></h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2016%20%2FFunctions%20as%20Data%2F">
<p>
The chapter on streams will explain some calculus notation converting it to a pyret function. The symbol \(\varepsilon\) is epsilon which is a small positive qty, and "functions of arity one" means one parameter of input. There's a <a href="https://www.pyret.org/docs/latest/A_Tour_of_Pyret.html#%28part._.For_loops%29">for loop</a> used in the check block which is an iterator. We learn more about the ( -&gt;) notation, meaning no arguments. The fibonacci example, change the starting values around so you can see what's going on. You first lz-link 0 and 1 then those values are mapped over, producing a new value, which gets mapped over again etc. 
</p>
</div>
</div>

<div id="outline-container-Lab%3A%20Streams" class="outline-3">
<h3 id="Lab%3A%20Streams">Lab: Streams</h3>
<div class="outline-text-3" id="text-Lab%3A%20Streams">
<p>
The streams lab is <a href="https://cs.brown.edu/courses/cs019/2016/streams-lab.pdf">here</a>, mostly adapted from the chapter we just read in PAPL. We already wrote map and map2, try to write your own filter/fold for streams:
</p>

<pre class="example" id="orgbe529f7">
fun lz-fold&lt;A, B&gt;(f :: (A, B -&gt; A), base :: A, s :: Stream&lt;B&gt;) -&gt; Stream&lt;A&gt;:
  lz-link(f(base, lz-first(s)), lam(): lz-fold(f, f(base, lz-first(s)), lz-rest(s)) end) 
end

fun lz-filter&lt;A, B&gt;(f :: (A -&gt; Boolean), s :: Stream&lt;B&gt;) -&gt; Stream&lt;A&gt;:
  if f(lz-first(s)) == true:
    lz-link(lz-first(s), lam(): lz-filter(f, lz-rest(s)) end)
  else:
    lz-filter(f, lz-rest(s))
  end
end

&gt;&gt; take(10, lz-filter(lam(x): if x &gt; 10: true else: false end end, nats))
[list: 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

&gt;&gt; take(10, lz-fold(lam(x, y): x + y end, 0, nats))
[list: 0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
</pre>
</div>
</div>
</div>


<div id="outline-container-Lecture%2012%20Model%20View%20Controllers" class="outline-2">
<h2 id="Lecture%2012%20Model%20View%20Controllers">Lecture 12 Model View Controllers</h2>
<div class="outline-text-2" id="text-Lecture%2012%20Model%20View%20Controllers">
<p>
This is lecture Wed10/3/18. You can't see the entire whiteboard in the beginning but it doesn't matter, this is a lecture about seperation of concerns when building large systems, how to embody the essence of a system into a model that is common to all parts of the system.
</p>
</div>
</div>

<div id="outline-container-Lecture%2013%20Differential%20Systems" class="outline-2">
<h2 id="Lecture%2013%20Differential%20Systems">Lecture 13 Differential Systems</h2>
<div class="outline-text-2" id="text-Lecture%2013%20Differential%20Systems">
<p>
Lecture Fri10/05/18. Using same reactor model to make a point about differential systems. Interesting examples about PID controllers/reactive systems, event loops, checkpoints of the state of the system.   
</p>
</div>
</div>

<div id="outline-container-Lecture%2014%20Aliasing" class="outline-2">
<h2 id="Lecture%2014%20Aliasing">Lecture 14 Aliasing</h2>
<div class="outline-text-2" id="text-Lecture%2014%20Aliasing">
<p>
Lecture Wed10/10/18. A great lecture about memory aliasing, introduces directed acyclic graphs, which is what <a href="https://eagain.net/articles/git-for-computer-scientists/">git</a> is. There is <a href="https://papl.cs.brown.edu/2020/Sharing_and_Equality.html">reading</a> for this lecture introducing identical to check the memory reference, meaning the result of the same act of value construction.  
</p>
</div>
</div>

<div id="outline-container-Lecture%2015%20Monads%2C%20Sequential%20Computation" class="outline-2">
<h2 id="Lecture%2015%20Monads%2C%20Sequential%20Computation">Lecture 15 Monads, Sequential Computation</h2>
<div class="outline-text-2" id="text-Lecture%2015%20Monads%2C%20Sequential%20Computation">
<p>
Lecture Fri10/12/18. He's going over some BTree code handed out in Piazza (we don't have access), but we've seen all this code before it's just a BTree. Note the check blocks can have strings, so when you run a test you know which one failed such as check "if leaves are zero": &#x2026;test.. end. We discover this is a design pattern that allows abstracting out this pattern of carrying information and it's called monadic programming.
</p>

<p>
The end of the lecture he walks through the code of a pyret library he wrote, explaining all the complicated types and notation, you can use this to look up the source yourself when doing assignments and <a href="https://github.com/brownplt/pyret-lang/tree/horizon/src/arr/trove">read</a> the code.
</p>
</div>
</div>

<div id="outline-container-CS19%20Lectures%20on%20Graphs" class="outline-2">
<h2 id="CS19%20Lectures%20on%20Graphs">CS19 Lectures on Graphs</h2>
<div class="outline-text-2" id="text-CS19%20Lectures%20on%20Graphs">
<p>
Lecture 16 - 21 cover graphs and queues. TODO
</p>
</div>
</div>



<div id="outline-container-CS19%20Lectures%20on%20mutation" class="outline-2">
<h2 id="CS19%20Lectures%20on%20mutation">CS19 Lectures on mutation</h2>
<div class="outline-text-2" id="text-CS19%20Lectures%20on%20mutation">
<p>
Watch lecture 23 Wed10/31/18, and skip to 40:00. Here we learn about objects such as using the 'this' keyword in java/javascript and memory referencing. Everything in this lecture is in PAPL too such as identical which means two things are identical if changing one thing also changes the other (aliasing). 
</p>

<p>
Your lecture should start with the Box datatype. "Your programs now have a notion of time" aka state, the state of things at time x. The {} expression is an <a href="https://www.pyret.org/docs/latest/Expressions.html#%28elem._%28bnf-prod._%28.Pyret._obj-expr%29%29%29">object</a>. You may have heard of the term 'unboxing variables', this is what we are learning. In say the C# programming language, boxing is the process of converting a primitive type like int and char into an object type. This is the building blocks of object oriented programming. 
</p>
</div>

<div id="outline-container-Lecture%2024%20Memory%20refs" class="outline-3">
<h3 id="Lecture%2024%20Memory%20refs">Lecture 24 Memory refs</h3>
<div class="outline-text-3" id="text-Lecture%2024%20Memory%20refs">
<p>
Watching lecture Fri 11/2/18. This is similar to how StandardML does variable mutation with refs boxes. Once he goes back to talking about union-find you can abandon the lecture, we will return and watch it when we learn it in competitive programming.
</p>
</div>
</div>

<div id="outline-container-Lecture%2025%20Closures" class="outline-3">
<h3 id="Lecture%2025%20Closures">Lecture 25 Closures</h3>
<div class="outline-text-3" id="text-Lecture%2025%20Closures">
<p>
Watching <a href="https://youtu.be/munnj3BXJCc">lecture</a> Mon 11/5/18. A part of this lecture is offscreen, but the point is equal-never is impossible to implement with state/mutation because of time, in the future it could be equal if mutated. Closures are discussed, from the book <i>Programming in SML</i>:    
</p>

<blockquote>
<p>
One way to understand what’s going on here is through the concept of a closure, a technique for implementing higher-order functions. When a function expression is evaluated, a copy of the environment is attached to the function. Subsequently, all free variables of the function (i.e., those variables not occurring as parameters) are resolved with respect to the environment attached to the function; the function is therefore said to be “closed” with respect to the attached environment. This is achieved at function application time by “swapping” the attached environment of the function for the environment active at the point of the call. The swapped environment is restored after the call is complete.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-PAPL%20Chapter%2022" class="outline-3">
<h3 id="PAPL%20Chapter%2022">PAPL Chapter 22</h3>
<div class="outline-text-3" id="text-PAPL%20Chapter%2022">
<p>
Identical, closures and recursion is explained in this <a href="https://papl.cs.brown.edu/2020/State__Change__and_More_Equality.html">chapter</a>. Chapter 32 also has the cs173 <a href="https://papl.cs.brown.edu/2020/implementing-mutation.html">version</a> of closures.
</p>
</div>
</div>


<div id="outline-container-The%20rest%20of%20the%20cs19%20lectures" class="outline-3">
<h3 id="The%20rest%20of%20the%20cs19%20lectures">The rest of the cs19 lectures</h3>
<div class="outline-text-3" id="text-The%20rest%20of%20the%20cs19%20lectures">
<p>
We will take them as these topics come up:
</p>
<ul class="org-ul">
<li>Lecture 16 to 21 Graphs and Dijkstra's algorithm, Queues (lecture 19)</li>
<li>Lecture 22 Brown students talk about future courses to take</li>
<li>Lecture 23 and 24 is union find/min spanning trees (and mutation we already saw)</li>
<li>Lecture 26 The Halting Problem</li>
<li>Lecture 27 &amp; 28 Memoization</li>
<li>Lecture 29 Dynamic Programming</li>
<li>Lecture 30 Levenshtein Distance (spell checkers)</li>
<li>Lecture 31 P = NP</li>
<li>Lecture 32 - 34 Programming languages 
<ul class="org-ul">
<li>discusses what PL researchers do, shows you how he wrote PAPL using Racket scribble</li>
</ul></li>
<li>Lecture 35 How computer networks work w/graphs (not in PAPL)</li>
<li>Lecture 36 Security (not in PAPL)</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-Algorithms" class="outline-2">
<h2 id="Algorithms">Algorithms</h2>
<div class="outline-text-2" id="text-Algorithms">
<p>
TODO
</p>







<hr>
<p>
<a href="./index.html">Home</a>
</p>
</div>
</div>
</div>
</body>
</html>
